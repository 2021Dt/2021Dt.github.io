<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>algorithm | dpのweb</title><meta name="author" content="dp2024"><meta name="copyright" content="dp2024"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="自学算法的笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="algorithm">
<meta property="og:url" content="http://2021dt.github.io/posts/9505ccb9/index.html">
<meta property="og:site_name" content="dpのweb">
<meta property="og:description" content="自学算法的笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://2021dt.github.io/img/cover2.jpg">
<meta property="article:published_time" content="2024-02-28T01:09:47.000Z">
<meta property="article:modified_time" content="2024-03-24T08:44:19.010Z">
<meta property="article:author" content="dp2024">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://2021dt.github.io/img/cover2.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://2021dt.github.io/posts/9505ccb9/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":200,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: dp2024","link":"链接: ","source":"来源: dpのweb","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'algorithm',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-24 16:44:19'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/backgound.css"><link rel="stylesheet" href="/css/color.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/rightmenu.css"><link rel="stylesheet" href="/css/custom2.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><link rel="stylesheet" href="/css/custom3.css"><link rel="stylesheet" href="/css/preloader.css"><link rel="stylesheet" href="/css/gunluntiao.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.0.0"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="/css/progress_bar.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 小窝</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 总览</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fas fa-video"></i><span> 追番</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./img/background.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="dpのweb"><span class="site-name">dpのweb</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 小窝</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 总览</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fas fa-video"></i><span> 追番</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div><div id="randomPost"></div><a class="site-page social-icon search" href="javascript:;" onclick="randomPost()" title="随机访问一篇文章"><i class="fas fa-circle-notch fa-fw"></i></a></nav><div id="post-info"><h1 class="post-title">algorithm</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-28T01:09:47.000Z" title="发表于 2024-02-28 09:09:47">2024-02-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-24T08:44:19.010Z" title="更新于 2024-03-24 16:44:19">2024-03-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="algorithm"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="链表">链表</h1>
<p>内存空间是所有程序的公共资源，在一个复杂的系统运行环境下，空闲的内存空间可能散落在内存各处。我们知道，存储数组的内存空间必须是连续的，而当数组非常大时，内存可能无法提供如此大的连续空间。此时链表的灵活性优势就体现出来了。</p>
<p>「链表 linked list」是一种线性数据结构，其中的每个元素都是一个节点对象，各个节点通过“引用”相连接。引用记录了下一个节点的内存地址，通过它可以从当前节点访问到下一个节点。</p>
<p>链表的设计使得各个节点可以分散存储在内存各处，它们的内存地址无须连续。</p>
<p>链表的组成单位是「节点 node」对象。每个节点都包含两项数据：节点的“值”和指向下一节点的“引用”。</p>
<ul>
<li>链表的首个节点被称为“头节点”，最后一个节点被称为“尾节点”。</li>
<li>尾节点指向的是“空”，它在 Java、C++ 和 Python 中分别被记为 null、nullptr 和 None 。</li>
<li>在 C、C++、Go 和 Rust 等支持指针的语言中，上述“引用”应被替换为“指针”。</li>
</ul>
<p>u 链表节点 <code>ListNode</code> 除了包含值，还需额外保存一个引用（指针）。<em><strong>因此在相同数据量下，链表比数组占用更多的内存空间。</strong></em></p>
<h2 id="初始化链表">初始化链表</h2>
<div class="tabs" id="初始化代码"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="初始化代码-1">Python</button><button type="button" class="tab " data-href="初始化代码-2">C++</button><button type="button" class="tab " data-href="初始化代码-3">Java</button><button type="button" class="tab " data-href="初始化代码-4">C#</button><button type="button" class="tab " data-href="初始化代码-5">JS</button></ul><div class="tab-contents"><div class="tab-item-content active" id="初始化代码-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;链表节点类&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val: <span class="built_in">int</span></span>):</span><br><span class="line">        self.val: <span class="built_in">int</span> = val               <span class="comment"># 节点值</span></span><br><span class="line">        self.<span class="built_in">next</span>: ListNode | <span class="literal">None</span> = <span class="literal">None</span> <span class="comment"># 指向下一节点的引用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化链表 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4</span></span><br><span class="line"><span class="comment"># 初始化各个节点</span></span><br><span class="line">n0 = ListNode(<span class="number">1</span>)</span><br><span class="line">n1 = ListNode(<span class="number">3</span>)</span><br><span class="line">n2 = ListNode(<span class="number">2</span>)</span><br><span class="line">n3 = ListNode(<span class="number">5</span>)</span><br><span class="line">n4 = ListNode(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># 构建节点之间的引用</span></span><br><span class="line">n0.<span class="built_in">next</span> = n1</span><br><span class="line">n1.<span class="built_in">next</span> = n2</span><br><span class="line">n2.<span class="built_in">next</span> = n3</span><br><span class="line">n3.<span class="built_in">next</span> = n4</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-2"><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 链表节点结构体 */</span></span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    <span class="built_in">int</span> val;         <span class="comment">// 节点值</span></span><br><span class="line">    ListNode *<span class="keyword">next</span>;  <span class="comment">// 指向下一节点的指针</span></span><br><span class="line">    ListNode(<span class="built_in">int</span> x) : val(x), <span class="keyword">next</span>(nullptr) &#123;&#125;  <span class="comment">// 构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化链表 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */</span></span><br><span class="line"><span class="comment">// 初始化各个节点</span></span><br><span class="line">ListNode* n0 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">ListNode* n1 = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">ListNode* n2 = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">ListNode* n3 = <span class="keyword">new</span> ListNode(<span class="number">5</span>);</span><br><span class="line">ListNode* n4 = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// 构建节点之间的引用</span></span><br><span class="line">n0-&gt;<span class="keyword">next</span> = n1;</span><br><span class="line">n1-&gt;<span class="keyword">next</span> = n2;</span><br><span class="line">n2-&gt;<span class="keyword">next</span> = n3;</span><br><span class="line">n3-&gt;<span class="keyword">next</span> = n4;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-3"><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/* 链表节点类 */</span><br><span class="line">class ListNode &#123;</span><br><span class="line">    int val<span class="comment">;        // 节点值</span></span><br><span class="line">    ListNode next<span class="comment">;  // 指向下一节点的引用</span></span><br><span class="line">    ListNode(int x) &#123; val <span class="operator">=</span> x<span class="comment">; &#125;  // 构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 初始化链表 <span class="number">1</span> -&gt; <span class="number">3</span> -&gt; <span class="number">2</span> -&gt; <span class="number">5</span> -&gt; <span class="number">4</span> */</span><br><span class="line">// 初始化各个节点</span><br><span class="line">ListNode n0 <span class="operator">=</span> new ListNode(<span class="number">1</span>)<span class="comment">;</span></span><br><span class="line">ListNode n1 <span class="operator">=</span> new ListNode(<span class="number">3</span>)<span class="comment">;</span></span><br><span class="line">ListNode n2 <span class="operator">=</span> new ListNode(<span class="number">2</span>)<span class="comment">;</span></span><br><span class="line">ListNode n3 <span class="operator">=</span> new ListNode(<span class="number">5</span>)<span class="comment">;</span></span><br><span class="line">ListNode n4 <span class="operator">=</span> new ListNode(<span class="number">4</span>)<span class="comment">;</span></span><br><span class="line">// 构建节点之间的引用</span><br><span class="line">n0.next <span class="operator">=</span> n1<span class="comment">;</span></span><br><span class="line">n1.next <span class="operator">=</span> n2<span class="comment">;</span></span><br><span class="line">n2.next <span class="operator">=</span> n3<span class="comment">;</span></span><br><span class="line">n3.next <span class="operator">=</span> n4<span class="comment">;</span></span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-4"><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 链表节点类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>(<span class="built_in">int</span> x) &#123;  <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">int</span> val = x;         <span class="comment">// 节点值</span></span><br><span class="line">    ListNode? <span class="keyword">next</span>;      <span class="comment">// 指向下一节点的引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化链表 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */</span></span><br><span class="line"><span class="comment">// 初始化各个节点</span></span><br><span class="line">ListNode n0 = <span class="keyword">new</span>(<span class="number">1</span>);</span><br><span class="line">ListNode n1 = <span class="keyword">new</span>(<span class="number">3</span>);</span><br><span class="line">ListNode n2 = <span class="keyword">new</span>(<span class="number">2</span>);</span><br><span class="line">ListNode n3 = <span class="keyword">new</span>(<span class="number">5</span>);</span><br><span class="line">ListNode n4 = <span class="keyword">new</span>(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// 构建节点之间的引用</span></span><br><span class="line">n0.<span class="keyword">next</span> = n1;</span><br><span class="line">n1.<span class="keyword">next</span> = n2;</span><br><span class="line">n2.<span class="keyword">next</span> = n3;</span><br><span class="line">n3.<span class="keyword">next</span> = n4;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-5"><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 链表节点类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    constructor(val, <span class="keyword">next</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = (val === undefined ? <span class="number">0</span> : val);       <span class="comment">// 节点值</span></span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">next</span> = (<span class="keyword">next</span> === undefined ? <span class="literal">null</span> : <span class="keyword">next</span>); <span class="comment">// 指向下一节点的引用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化链表 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */</span></span><br><span class="line"><span class="comment">// 初始化各个节点</span></span><br><span class="line"><span class="keyword">const</span> n0 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> n1 = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> n2 = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> n3 = <span class="keyword">new</span> ListNode(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">const</span> n4 = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// 构建节点之间的引用</span></span><br><span class="line">n0.<span class="keyword">next</span> = n1;</span><br><span class="line">n1.<span class="keyword">next</span> = n2;</span><br><span class="line">n2.<span class="keyword">next</span> = n3;</span><br><span class="line">n3.<span class="keyword">next</span> = n4;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h2 id="插入结点">插入结点</h2>
<ul>
<li>插入结点就是让插入的结点指向后结点，再让前结点指向插入结点。</li>
</ul>
<div class="tabs" id="初始化代码"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="初始化代码-1">Python</button><button type="button" class="tab " data-href="初始化代码-2">C++</button><button type="button" class="tab " data-href="初始化代码-3">Java</button><button type="button" class="tab " data-href="初始化代码-4">C#</button><button type="button" class="tab " data-href="初始化代码-5">JS</button></ul><div class="tab-contents"><div class="tab-item-content active" id="初始化代码-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">n0: ListNode, P: ListNode</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;在链表的节点 n0 之后插入节点 P&quot;&quot;&quot;</span></span><br><span class="line">    n1 = n0.<span class="built_in">next</span></span><br><span class="line">    P.<span class="built_in">next</span> = n1</span><br><span class="line">    n0.<span class="built_in">next</span> = P</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-2"><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在链表的节点 n0 之后插入节点 P */</span></span><br><span class="line"><span class="keyword">void</span> insert(ListNode *n0, ListNode *P) &#123;</span><br><span class="line">    ListNode *n1 = n0-&gt;<span class="keyword">next</span>;</span><br><span class="line">    P-&gt;<span class="keyword">next</span> = n1;</span><br><span class="line">    n0-&gt;<span class="keyword">next</span> = P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-3"><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在链表的节点 n0 之后插入节点 P */</span></span><br><span class="line"><span class="keyword">void</span> insert(ListNode n0, ListNode P) &#123;</span><br><span class="line">    ListNode n1 = n0.<span class="keyword">next</span>;</span><br><span class="line">    P.<span class="keyword">next</span> = n1;</span><br><span class="line">    n0.<span class="keyword">next</span> = P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-4"><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在链表的节点 n0 之后插入节点 P */</span></span><br><span class="line"><span class="keyword">void</span> Insert(ListNode n0, ListNode P) &#123;</span><br><span class="line">    ListNode? n1 = n0.<span class="keyword">next</span>;</span><br><span class="line">    P.<span class="keyword">next</span> = n1;</span><br><span class="line">    n0.<span class="keyword">next</span> = P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-5"><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/* 在链表的节点 n0 之后插入节点 P */</span></span><br><span class="line"><span class="keyword">function</span> insert(n0, P) &#123;</span><br><span class="line">    const n1 = n0.<span class="keyword">next</span>;</span><br><span class="line">    P.<span class="keyword">next</span> = n1;</span><br><span class="line">    n0.<span class="keyword">next</span> = P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h2 id="删除结点">删除结点</h2>
<ul>
<li>捋清楚前后关系，其实删除结点就是将前一个结点指向不在指向被删除的结点，而是指向被删除结点之后的结点。</li>
</ul>
<div class="tabs" id="初始化代码"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="初始化代码-1">Python</button><button type="button" class="tab " data-href="初始化代码-2">C++</button><button type="button" class="tab " data-href="初始化代码-3">Java</button><button type="button" class="tab " data-href="初始化代码-4">C#</button><button type="button" class="tab " data-href="初始化代码-5">JS</button></ul><div class="tab-contents"><div class="tab-item-content active" id="初始化代码-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">n0: ListNode</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;删除链表的节点 n0 之后的首个节点&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> n0.<span class="built_in">next</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># n0 -&gt; P -&gt; n1</span></span><br><span class="line">    P = n0.<span class="built_in">next</span></span><br><span class="line">    n1 = P.<span class="built_in">next</span></span><br><span class="line">    n0.<span class="built_in">next</span> = n1</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-2"><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 删除链表的节点 n0 之后的首个节点 */</span></span><br><span class="line">void remove(ListNode *n0) &#123;</span><br><span class="line">    <span class="function"><span class="title">if</span> (n0-&gt;</span>next == nullptr)</span><br><span class="line">        return;</span><br><span class="line">    <span class="comment">// n0 -&gt; P -&gt; n1</span></span><br><span class="line">    L<span class="function"><span class="title">istNode</span> *P = n0-&gt;</span>next;</span><br><span class="line">    L<span class="function"><span class="title">istNode</span> *n1 = P-&gt;</span>next;</span><br><span class="line">    <span class="function"><span class="title">n0</span>-&gt;</span>next = n1;</span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    delete P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-3"><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* 删除链表的节点 n0 之后的首个节点 */</span><br><span class="line">void remove(ListNode n0) &#123;</span><br><span class="line">    if (n0.next <span class="operator">=</span><span class="operator">=</span> null)</span><br><span class="line">        return<span class="comment">;</span></span><br><span class="line">    // n0 -&gt; P -&gt; n1</span><br><span class="line">    ListNode P <span class="operator">=</span> n0.next<span class="comment">;</span></span><br><span class="line">    ListNode n1 <span class="operator">=</span> P.next<span class="comment">;</span></span><br><span class="line">    n0.next <span class="operator">=</span> n1<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-4"><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 删除链表的节点 n0 之后的首个节点 */</span></span><br><span class="line">function remove(n0) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!n0.<span class="keyword">next</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// n0 -&gt; P -&gt; n1</span></span><br><span class="line">    <span class="keyword">const</span> P = n0.<span class="keyword">next</span>;</span><br><span class="line">    <span class="keyword">const</span> n1 = P.<span class="keyword">next</span>;</span><br><span class="line">    n0.<span class="keyword">next</span> = n1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-5"><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/* 在链表的节点 n0 之后插入节点 P */</span></span><br><span class="line"><span class="keyword">function</span> insert(n0, P) &#123;</span><br><span class="line">    const n1 = n0.<span class="keyword">next</span>;</span><br><span class="line">    P.<span class="keyword">next</span> = n1;</span><br><span class="line">    n0.<span class="keyword">next</span> = P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h2 id="访问结点和查找结点">访问结点和查找结点</h2>
<p>***在链表中访问节点的效率较低。***我们可以在$O(1)$时间下访问数组中的任意元素。链表则不然，程序需要从头节点出发，逐个向后遍历，直至找到目标节点。也就是说，访问链表的第$i$个节点需要循环$i-1$轮，时间复杂度为$O(n)$。</p>
<blockquote>
<p>查找结点也是循环遍历。</p>
</blockquote>
<h2 id="数组和链表的区别">数组和链表的区别</h2>
<ul>
<li>存储方式不同：前者是 <em><strong>连续内存空间</strong></em>，后者是 <em><strong>分散内存空间</strong></em></li>
<li>容量扩展不同：前者是 <em><strong>长度不可变</strong></em>，后者是 <em><strong>可灵活扩展</strong></em></li>
<li>内存效率不同：前者是 <em><strong>元素占用内存少、但可能浪费空间</strong></em>，后者是 <em><strong>元素占用内存多</strong></em></li>
<li>访问元素速度不同：前者是 <em><strong>$O(1)$</strong></em>，后者是 <em><strong>$O(n)$</strong></em></li>
<li>添加和删除元素速度不同：前者是 <em><strong>$O(n)$</strong></em>，后者是 <em><strong>$O(1)$</strong></em></li>
</ul>
<h2 id="常见链表类型">常见链表类型</h2>
<ul>
<li>单向链表：即前面介绍的普通链表。单向链表的节点包含值和指向下一节点的引用两项数据。我们将首个节点称为头节点，将最后一个节点称为尾节点，尾节点指向空 <code>None</code> 。</li>
<li>环形链表：如果我们令单向链表的尾节点指向头节点（首尾相接），则得到一个环形链表。在环形链表中，任意节点都可以视作头节点。</li>
<li>双向链表：与单向链表相比，双向链表记录了两个方向的引用。双向链表的节点定义同时包含指向后继节点（下一个节点）和前驱节点（上一个节点）的引用（指针）。相较于单向链表，双向链表更具灵活性，可以朝两个方向遍历链表，但相应地也需要占用更多的内存空间。</li>
</ul>
<div class="tabs" id="初始化代码"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="初始化代码-1">Python</button><button type="button" class="tab " data-href="初始化代码-2">C++</button><button type="button" class="tab " data-href="初始化代码-3">Java</button><button type="button" class="tab " data-href="初始化代码-4">C#</button><button type="button" class="tab " data-href="初始化代码-5">JS</button></ul><div class="tab-contents"><div class="tab-item-content active" id="初始化代码-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;双向链表节点类&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val: <span class="built_in">int</span></span>):</span><br><span class="line">        self.val: <span class="built_in">int</span> = val                <span class="comment"># 节点值</span></span><br><span class="line">        self.<span class="built_in">next</span>: ListNode | <span class="literal">None</span> = <span class="literal">None</span>  <span class="comment"># 指向后继节点的引用</span></span><br><span class="line">        self.prev: ListNode | <span class="literal">None</span> = <span class="literal">None</span>  <span class="comment"># 指向前驱节点的引用</span></span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-2"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 双向链表节点结构体 */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;         <span class="comment">// 节点值</span></span><br><span class="line">    ListNode *next;  <span class="comment">// 指向后继节点的指针</span></span><br><span class="line">    ListNode *prev;  <span class="comment">// 指向前驱节点的指针</span></span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>), <span class="built_in">prev</span>(<span class="literal">nullptr</span>) &#123;&#125;  <span class="comment">// 构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-3"><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 双向链表节点类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> val;        <span class="comment">// 节点值</span></span><br><span class="line">    ListNode <span class="keyword">next</span>;  <span class="comment">// 指向后继节点的引用</span></span><br><span class="line">    ListNode prev;  <span class="comment">// 指向前驱节点的引用</span></span><br><span class="line">    ListNode(<span class="built_in">int</span> x) &#123; val = x; &#125;  <span class="comment">// 构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-4"><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 双向链表节点类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">ListNode</span>(<span class="symbol">int</span> <span class="symbol">x</span>) &#123;  <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">int</span> val = x;    <span class="comment">// 节点值</span></span><br><span class="line">    ListNode next;  <span class="comment">// 指向后继节点的引用</span></span><br><span class="line">    ListNode prev;  <span class="comment">// 指向前驱节点的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-5"><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 双向链表节点类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="keyword">val</span>, next, prev) &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">val</span> = <span class="keyword">val</span>  ===  undefined ? <span class="number">0</span> : <span class="keyword">val</span>;        <span class="comment">// 节点值</span></span><br><span class="line">        <span class="keyword">this</span>.next = next  ===  undefined ? <span class="literal">null</span> : next;  <span class="comment">// 指向后继节点的引用</span></span><br><span class="line">        <span class="keyword">this</span>.prev = prev  ===  undefined ? <span class="literal">null</span> : prev;  <span class="comment">// 指向前驱节点的引用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h2 id="链表的基本应用">链表的基本应用</h2>
<p>单向链表通常用于实现栈、队列、哈希表和图等数据结构。</p>
<ul>
<li>
<p><em><strong>栈与队列</strong></em>：当插入和删除操作都在链表的一端进行时，它表现出先进后出的特性，对应栈；当插入操作在链表的一端进行，删除操作在链表的另一端进行，它表现出先进先出的特性，对应队列。</p>
</li>
<li>
<p><em><strong>哈希表</strong></em>：链式地址是解决哈希冲突的主流方案之一，在该方案中，所有冲突的元素都会被放到一个链表中。</p>
</li>
<li>
<p><em><strong>图</strong></em>：邻接表是表示图的一种常用方式，其中图的每个顶点都与一个链表相关联，链表中的每个元素都代表与该顶点相连的其他顶点。<br>
双向链表常用于需要快速查找前一个和后一个元素的场景。</p>
</li>
<li>
<p><em><strong>高级数据结构</strong></em>：比如在红黑树、B 树中，我们需要访问节点的父节点，这可以通过在节点中保存一个指向父节点的引用来实现，类似于双向链表。<br>
浏览器历史：在网页浏览器中，当用户点击前进或后退按钮时，浏览器需要知道用户访问过的前一个和后一个网页。双向链表的特性使得这种操作变得简单。</p>
</li>
<li>
<p><em><strong>LRU 算法</strong></em>：在缓存淘汰（LRU）算法中，我们需要快速找到最近最少使用的数据，以及支持快速添加和删除节点。这时候使用双向链表就非常合适。<br>
环形链表常用于需要周期性操作的场景，比如操作系统的资源调度。</p>
</li>
<li>
<p><em><strong>时间片轮转调度算法</strong></em>：在操作系统中，时间片轮转调度算法是一种常见的 CPU 调度算法，它需要对一组进程进行循环。每个进程被赋予一个时间片，当时间片用完时，CPU 将切换到下一个进程。这种循环操作可以通过环形链表来实现。</p>
</li>
<li>
<p><em><strong>数据缓冲区</strong></em>：在某些数据缓冲区的实现中，也可能会使用环形链表。比如在音频、视频播放器中，数据流可能会被分成多个缓冲块并放入一个环形链表，以便实现无缝播放。</p>
</li>
</ul>
<h2 id="总结">总结</h2>
<ul>
<li>捋清楚每个元素指向的位置是写好链表算法最为重要的一步。</li>
<li>数组和链表是两种基本的数据结构，分别代表数据在计算机内存中的两种存储方式：连续空间存储和分散空间存储。两者的特点呈现出互补的特性。</li>
<li>数组支持随机访问、占用内存较少；但插入和删除元素效率低，且初始化后长度不可变。</li>
<li>链表通过更改引用（指针）实现高效的节点插入与删除，且可以灵活调整长度；但节点访问效率低、占用内存较多。常见的链表类型包括单向链表、环形链表、双向链表。</li>
<li>列表是一种支持增删查改的元素有序集合，通常基于动态数组实现。它保留了数组的优势，同时可以灵活调整长度。</li>
<li>列表的出现大幅提高了数组的实用性，但可能导致部分内存空间浪费。<br>
程序运行时，数据主要存储在内存中。数组可提供更高的内存空间效率，而链表则在内存使用上更加灵活。</li>
<li>缓存通过缓存行、预取机制以及空间局部性和时间局部性等数据加载机制，为 CPU 提供快速数据访问，显著提升程序的执行效率。</li>
<li>由于数组具有更高的缓存命中率，因此它通常比链表更高效。在选择数据结构时，应根据具体需求和场景做出恰当选择。</li>
<li>存储在栈上和堆上的数组都被存储在连续内存空间内，数据操作效率基本一致。然而，栈和堆具有各自的特点，从而导致以下不同点。<br> 1. 分配和释放效率：栈是一块较小的内存，分配由编译器自动完成；而堆内存相对更大，可以在代码中动态分配，更容易碎片化。因此，堆上的分配和释放操作通常比栈上的慢。<br> 2. 大小限制：栈内存相对较小，堆的大小一般受限于可用内存。因此堆更加适合存储大型数组。<br> 3. 灵活性：栈上的数组的大小需要在编译时确定，而堆上的数组的大小可以在运行时动态确定。</li>
</ul>
<h2 id="链表算法练习">链表算法练习</h2>
<h3 id="反转链表1"><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/illustration-of-algorithm/7fpt1m/">反转链表1</a></h3>
<blockquote>
<p>输入：head = [3,6,4,1]<br>
输出：[1,4,6,3]</p>
</blockquote>
<p>反转有着 <em><strong>后进先出</strong></em> 的特性，所以可以使用栈来解决问题<br>
由于重复性操作，本题也可以使用递归。<br>
注意返回的是数组哦。</p>
<p>Java代码如下</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * public <span class="keyword">class</span> <span class="type">ListNode</span> &#123;</span><br><span class="line"> *     <span class="built_in">int</span> <span class="keyword">val</span>;</span><br><span class="line"> *     <span class="type">ListNode</span> next;</span><br><span class="line"> *     <span class="type">ListNode</span><span class="literal">()</span> &#123;&#125;</span><br><span class="line"> *     <span class="type">ListNode</span>(<span class="built_in">int</span> <span class="keyword">val</span>) &#123; this.<span class="keyword">val</span> = <span class="keyword">val</span>; &#125;</span><br><span class="line"> *     <span class="type">ListNode</span>(<span class="built_in">int</span> <span class="keyword">val</span>, <span class="type">ListNode</span> next) &#123; this.<span class="keyword">val</span> = <span class="keyword">val</span>; this.next = next; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">class</span> <span class="type">Solution</span> &#123;</span><br><span class="line">    public <span class="built_in">int</span><span class="literal">[]</span> reverseBookList(<span class="type">ListNode</span> head) &#123;</span><br><span class="line">        <span class="type">Stack</span>&lt;<span class="type">Integer</span>&gt;ans = <span class="keyword">new</span> <span class="type">Stack</span>&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=null)&#123;</span><br><span class="line">            ans.push(head.<span class="keyword">val</span>);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span><span class="literal">[]</span> tmp = <span class="keyword">new</span> <span class="built_in">int</span>[ans.size<span class="literal">()</span>];</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!ans.isEmpty<span class="literal">()</span>)&#123;</span><br><span class="line">            tmp[i] = ans.pop<span class="literal">()</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        return tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="反转列表2"><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/illustration-of-algorithm/7fadz7/">反转列表2</a></h3>
<blockquote>
<p>输入：head = [1,2,3,4,5]<br>
输出：[5,4,3,2,1]</p>
</blockquote>
<p>定义一个头节点用于循环遍历，再定义一个空结点用于储存，让头节点指向储存结点就可以达到反转效果。1 到 1 &lt;-2 到 1 &lt;- 2 &lt;- 3 ···</p>
<p>Java代码如下：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/**</span></span><br><span class="line"> <span class="operator">*</span> <span class="keyword">public</span> <span class="keyword">class</span> ListNode &#123;</span><br><span class="line"> <span class="operator">*</span>     int <span class="keyword">val</span>;</span><br><span class="line"> <span class="operator">*</span>     ListNode next;</span><br><span class="line"> <span class="operator">*</span>     ListNode() &#123;&#125;</span><br><span class="line"> <span class="operator">*</span>     ListNode(int <span class="keyword">val</span>) &#123; this.<span class="keyword">val</span> <span class="operator">=</span> <span class="keyword">val</span>; &#125;</span><br><span class="line"> <span class="operator">*</span>     ListNode(int <span class="keyword">val</span>, ListNode next) &#123; this.<span class="keyword">val</span> <span class="operator">=</span> <span class="keyword">val</span>; this.next <span class="operator">=</span> next; &#125;</span><br><span class="line"> <span class="operator">*</span> &#125;</span><br><span class="line"> <span class="operator">*/</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode trainningPlan(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head<span class="operator">==</span><span class="literal">null</span>)<span class="keyword">return</span> head;</span><br><span class="line">        ListNode pre <span class="operator">=</span> <span class="literal">null</span> ,cur <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur<span class="operator">!=</span><span class="literal">null</span>)&#123;</span><br><span class="line">            ListNode tmp <span class="operator">=</span> cur.next;<span class="comment">//记录下一个结点，防止丢失。</span></span><br><span class="line">            cur.next <span class="operator">=</span> pre;<span class="comment">//让头节点指向存储结点。</span></span><br><span class="line">            pre <span class="operator">=</span> cur;<span class="comment">//存储数据</span></span><br><span class="line">            cur <span class="operator">=</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除节点"><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/illustration-of-algorithm/7fmls1/">删除节点</a></h3>
<blockquote>
<p>输入: head = [4,5,1,9], val = 5<br>
输出: [4,1,9]<br>
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</p>
</blockquote>
<p>本题思路有两种思路，一种是多走一步，一种是快慢指针。</p>
<p>Java代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多走一步</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode deleteNode(ListNode head, int <span class="keyword">val</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span> || head.<span class="keyword">val</span>==<span class="keyword">val</span>)<span class="keyword">return</span> head.next;</span><br><span class="line">        ListNode first = head;</span><br><span class="line">        <span class="keyword">while</span>(head.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head.next.<span class="keyword">val</span>==<span class="keyword">val</span>)&#123;</span><br><span class="line">                head.next = head.next.next;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快慢指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode deleteNode(ListNode head, int <span class="keyword">val</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head.<span class="keyword">val</span>==<span class="keyword">val</span>)<span class="keyword">return</span> head.next;</span><br><span class="line">        ListNode quick=head,slow=head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(quick!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(quick.<span class="keyword">val</span>==<span class="keyword">val</span>)&#123;</span><br><span class="line">                slow.next = quick.next;<span class="comment">//让慢结点的下一个是快结点的下一个结点，就相当于跳过了等于要删除结点的快结点。</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = quick; <span class="comment">// 这个顺序是很重要的</span></span><br><span class="line">            quick = quick.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="倒序查找"><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/illustration-of-algorithm/7f2ng5/">倒序查找</a></h3>
<blockquote>
<p>请查找并返回倒数第 cnt 个的数据<br>
输入：head = [2,4,7,8], cnt = 1<br>
输出：8</p>
</blockquote>
<p>本题直接思路是循环遍历一遍得到链表长度length，用length-cnt可以得到顺序位置，再次循环得到答案。</p>
<p>深入思考一下可以发现当我们先走cnt,此时还未走的距离为length-cnt。这不就是我们想要的结果吗。那我们只需要在定义一个小跟班跟着这个结点走完全部路程，这个小跟班的位置不就是最后答案吗。</p>
<p>Java代码如下：</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     <span class="type">int</span> val;</span><br><span class="line"> *     ListNode <span class="built_in">next</span>;</span><br><span class="line"> *     ListNode() &#123;&#125;</span><br><span class="line"> *     ListNode(<span class="type">int</span> val) &#123; this.val = val; &#125;</span><br><span class="line"> *     ListNode(<span class="type">int</span> val, ListNode <span class="built_in">next</span>) &#123; this.val = val; this.<span class="built_in">next</span> = <span class="built_in">next</span>; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode trainingPlan(ListNode head, <span class="type">int</span> cnt) &#123;</span><br><span class="line">        ListNode <span class="built_in">first</span> = head ,second = head;</span><br><span class="line">        for(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)&#123;</span><br><span class="line">            <span class="built_in">first</span> = <span class="built_in">first</span>.<span class="built_in">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">first</span>!=<span class="built_in">null</span>)&#123;</span><br><span class="line">            <span class="built_in">first</span> = <span class="built_in">first</span>.<span class="built_in">next</span>;</span><br><span class="line">            second = second.<span class="built_in">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        return second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="合并有序链表"><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/illustration-of-algorithm/7fnm66/">合并有序链表</a></h3>
<blockquote>
<p>输入：l1 = [1,2,4], l2 = [1,3,4]<br>
输出：[1,1,2,3,4,4]</p>
</blockquote>
<p>直接思路比大小，直接构造链表</p>
<p>java代码如下:</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//直接比大小版本</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode trainningPlan(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        ListNode ans = <span class="keyword">new</span> ListNode(<span class="number">0</span>),pre = ans;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">null</span> &amp;&amp; l2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val&lt;l2.val)&#123;</span><br><span class="line">                pre.<span class="keyword">next</span> = l1;</span><br><span class="line">                l1 = l1.<span class="keyword">next</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pre.<span class="keyword">next</span> = l2;</span><br><span class="line">                l2 = l2.<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = pre.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.<span class="keyword">next</span> = l1!=<span class="literal">null</span>?l1:l2;</span><br><span class="line">        <span class="keyword">return</span> ans.<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归版本</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode trainningPlan(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="literal">null</span> || l2==<span class="literal">null</span>) <span class="keyword">return</span> l1==<span class="literal">null</span>?l2:l1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l1.val&gt;=l2.val)l2.<span class="keyword">next</span> = trainningPlan(l1,l2.<span class="keyword">next</span>);</span><br><span class="line">        <span class="keyword">else</span> l1.<span class="keyword">next</span> = trainningPlan(l1.<span class="keyword">next</span>,l2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> l1.val&gt;=l2.val?l2:l1;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查找相同结点"><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/illustration-of-algorithm/7fvoq2/">查找相同结点</a></h3>
<blockquote>
<p>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3<br>
输出：Reference of the node with value = 8<br>
解释：第一个正式训练项目编号为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p>
</blockquote>
<p>这题的思路很巧妙，当然完全可以通过两次循环去找到相同点，但是这需要额外开辟空间和多次循环。</p>
<p>设第一个公共节点为 <code>node</code> ，链表 <code>headA</code> 的节点数量为 <code>a</code> ，链表 <code>headB</code> 的节点数量为 <code>b</code> ，两链表的公共尾部的节点数量为 <code>c</code> ，则有：</p>
<ul>
<li>头节点 <code>headA</code> 到 <code>node</code> 前，共有 <code>a−c</code> 个节点；</li>
<li>头节点 <code>headB</code> 到 <code>node</code> 前，共有 <code>b−c</code> 个节点；</li>
</ul>
<p>考虑构建两个节点指针 <code>A</code>​ , <code>B</code> 分别指向两链表头节点 <code>headA</code> , <code>headB</code> ，做如下操作：</p>
<ul>
<li>指针 <code>A</code> 先遍历完链表 <code>headA</code> ，再开始遍历链表 <code>headB</code> ，当走到 <code>node </code>时，共走步数为：</li>
</ul>
<span class='p center'>$a+(b-c)$</span>
<ul>
<li>指针 <code>B</code> 先遍历完链表 <code>headB</code> ，再开始遍历链表 <code>headA</code> ，当走到 <code>node</code> 时，共走步数为：</li>
</ul>
<span class='p center'>$b+(a-c)$</span>
<p>如下式所示，此时指针 <code>A</code> , <code>B</code> 重合，并有两种情况：</p>
<span class='p center'>$a+(b−c)=b+(a−c)$</span>  
<ol>
<li>若两链表 <u>有</u> 公共尾部 (即 c &gt; 0 ) ：指针<code>A</code> , <code>B</code> 同时指向「第一个公共节点」<code>node</code> 。</li>
<li>若两链表 <u>无</u> 公共尾部 (即 c = 0 ) ：指针 <code>A</code> , <code>B</code> 同时指向<br>
<code>null</code>。<br>
因此返回<code>A</code>即可。</li>
</ol>
<p>java代码如下：</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> singly-linked list.</span><br><span class="line"> * <span class="keyword">public</span> <span class="keyword">class</span> ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode <span class="keyword">next</span>;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         <span class="keyword">next</span> = <span class="literal">null</span>;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;</span><br><span class="line">        ListNode a = headA,b = headB;</span><br><span class="line">        <span class="keyword">while</span>(a!=b)&#123;</span><br><span class="line">            a = a!=<span class="literal">null</span>?a.<span class="keyword">next</span>:headB;</span><br><span class="line">            b = b!=<span class="literal">null</span>?b.<span class="keyword">next</span>:headA;</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="栈与队列">栈与队列</h1>
<h2 id="栈的常用操作">栈的常用操作</h2>
<blockquote>
<p>「栈 stack」是一种遵循先入后出逻辑的线性数据结构。<br>
把堆叠元素的顶部称为“栈顶”，底部称为“栈底”。将把元素添加到栈顶的操作叫作“入栈”，删除栈顶元素的操作叫作“出栈”。</p>
</blockquote>
<ul>
<li>两个栈是可以模拟队列的。</li>
</ul>
<div class="tabs" id="初始化代码"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="初始化代码-1">Python</button><button type="button" class="tab " data-href="初始化代码-2">C++</button><button type="button" class="tab " data-href="初始化代码-3">Java</button><button type="button" class="tab " data-href="初始化代码-4">C#</button><button type="button" class="tab " data-href="初始化代码-5">JS</button></ul><div class="tab-contents"><div class="tab-item-content active" id="初始化代码-1"><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化栈</span></span><br><span class="line"><span class="comment"># Python 没有内置的栈类，可以把 list 当作栈来使用 </span></span><br><span class="line"><span class="attribute">stack</span>: list[int] =<span class="meta"> []</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 元素入栈</span></span><br><span class="line"><span class="attribute">stack</span>.append(<span class="number">1</span>)</span><br><span class="line"><span class="attribute">stack</span>.append(<span class="number">3</span>)</span><br><span class="line"><span class="attribute">stack</span>.append(<span class="number">2</span>)</span><br><span class="line"><span class="attribute">stack</span>.append(<span class="number">5</span>)</span><br><span class="line"><span class="attribute">stack</span>.append(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问栈顶元素</span></span><br><span class="line"><span class="attribute">peek</span>: int = stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 元素出栈</span></span><br><span class="line"><span class="attribute">pop</span>: int = stack.pop()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取栈的长度</span></span><br><span class="line"><span class="attribute">size</span>: int = len(stack)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否为空</span></span><br><span class="line"><span class="attribute">is_empty</span>: bool = len(stack) == <span class="number">0</span></span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-2"><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化栈 */</span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素入栈 */</span></span><br><span class="line">stack.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">stack.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">stack.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">stack.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">stack.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问栈顶元素 */</span></span><br><span class="line"><span class="type">int</span> top = stack.<span class="built_in">top</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素出栈 */</span></span><br><span class="line">stack.<span class="built_in">pop</span>(); <span class="comment">// 无返回值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取栈的长度 */</span></span><br><span class="line"><span class="type">int</span> size = stack.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断是否为空 */</span></span><br><span class="line"><span class="type">bool</span> empty = stack.<span class="built_in">empty</span>();</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-3"><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化栈 */</span></span><br><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素入栈 */</span></span><br><span class="line">stack.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">stack.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">stack.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">stack.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">stack.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问栈顶元素 */</span></span><br><span class="line"><span class="type">int</span> peek = stack.<span class="built_in">peek</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素出栈 */</span></span><br><span class="line"><span class="type">int</span> pop = stack.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取栈的长度 */</span></span><br><span class="line"><span class="type">int</span> size = stack.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断是否为空 */</span></span><br><span class="line"><span class="type">boolean</span> isEmpty = stack.<span class="built_in">isEmpty</span>();</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-4"><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化栈 */</span></span><br><span class="line">Stack&lt;<span class="keyword">int</span>&gt; stack = <span class="keyword">new</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素入栈 */</span></span><br><span class="line">stack.<span class="keyword">Push</span>(<span class="number">1</span>);</span><br><span class="line">stack.<span class="keyword">Push</span>(<span class="number">3</span>);</span><br><span class="line">stack.<span class="keyword">Push</span>(<span class="number">2</span>);</span><br><span class="line">stack.<span class="keyword">Push</span>(<span class="number">5</span>);</span><br><span class="line">stack.<span class="keyword">Push</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问栈顶元素 */</span></span><br><span class="line"><span class="keyword">int</span> peek = stack.Peek();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素出栈 */</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">pop</span> = stack.<span class="keyword">Pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取栈的长度 */</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">size</span> = stack.<span class="keyword">Count</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断是否为空 */</span></span><br><span class="line">bool isEmpty = stack.<span class="keyword">Count</span> == <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-5"><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化栈 */</span></span><br><span class="line"><span class="comment">// JavaScript 没有内置的栈类，可以把 Array 当作栈来使用 </span></span><br><span class="line"><span class="type">const</span> stack = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素入栈 */</span></span><br><span class="line">stack.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">stack.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">stack.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">stack.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">stack.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问栈顶元素 */</span></span><br><span class="line"><span class="type">const</span> peek = stack[stack.length<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素出栈 */</span></span><br><span class="line"><span class="type">const</span> pop = stack.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取栈的长度 */</span></span><br><span class="line"><span class="type">const</span> size = stack.length;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断是否为空 */</span></span><br><span class="line"><span class="type">const</span> is_empty = stack.length === <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h2 id="队列的基本操作">队列的基本操作</h2>
<blockquote>
<p>「队列 queue」是一种遵循先入先出规则的线性数据结构。<br>
将队列头部称为“队首”，尾部称为“队尾”，将把元素加入队尾的操作称为“入队”，删除队首元素的操作称为“出队”。</p>
</blockquote>
<div class="tabs" id="初始化代码"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="初始化代码-1">Python</button><button type="button" class="tab " data-href="初始化代码-2">C++</button><button type="button" class="tab " data-href="初始化代码-3">Java</button><button type="button" class="tab " data-href="初始化代码-4">C#</button><button type="button" class="tab " data-href="初始化代码-5">JS</button></ul><div class="tab-contents"><div class="tab-item-content active" id="初始化代码-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化队列</span></span><br><span class="line"><span class="comment"># 在 Python 中，我们一般将双向队列类 deque 当作队列使用</span></span><br><span class="line"><span class="comment"># 虽然 queue.Queue() 是纯正的队列类，但不太好用，因此不推荐</span></span><br><span class="line">que: deque[<span class="built_in">int</span>] = deque()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 元素入队</span></span><br><span class="line">que.append(<span class="number">1</span>)</span><br><span class="line">que.append(<span class="number">3</span>)</span><br><span class="line">que.append(<span class="number">2</span>)</span><br><span class="line">que.append(<span class="number">5</span>)</span><br><span class="line">que.append(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问队首元素</span></span><br><span class="line">front: <span class="built_in">int</span> = que[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment"># 元素出队</span></span><br><span class="line">pop: <span class="built_in">int</span> = que.popleft()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取队列的长度</span></span><br><span class="line">size: <span class="built_in">int</span> = <span class="built_in">len</span>(que)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断队列是否为空</span></span><br><span class="line">is_empty: <span class="built_in">bool</span> = <span class="built_in">len</span>(que) == <span class="number">0</span></span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-2"><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化队列 */</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素入队 */</span></span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问队首元素 */</span></span><br><span class="line"><span class="type">int</span> front = queue.<span class="built_in">front</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素出队 */</span></span><br><span class="line">queue.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取队列的长度 */</span></span><br><span class="line"><span class="type">int</span> size = queue.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断队列是否为空 */</span></span><br><span class="line"><span class="type">bool</span> empty = queue.<span class="built_in">empty</span>();</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-3"><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化队列 */</span></span><br><span class="line">Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素入队 */</span></span><br><span class="line">queue.<span class="built_in">offer</span>(<span class="number">1</span>);</span><br><span class="line">queue.<span class="built_in">offer</span>(<span class="number">3</span>);</span><br><span class="line">queue.<span class="built_in">offer</span>(<span class="number">2</span>);</span><br><span class="line">queue.<span class="built_in">offer</span>(<span class="number">5</span>);</span><br><span class="line">queue.<span class="built_in">offer</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问队首元素 */</span></span><br><span class="line"><span class="type">int</span> peek = queue.<span class="built_in">peek</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素出队 */</span></span><br><span class="line"><span class="type">int</span> pop = queue.<span class="built_in">poll</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取队列的长度 */</span></span><br><span class="line"><span class="type">int</span> size = queue.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断队列是否为空 */</span></span><br><span class="line"><span class="type">boolean</span> isEmpty = queue.<span class="built_in">isEmpty</span>();</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-4"><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化队列 */</span></span><br><span class="line">Queue&lt;<span class="type">int</span>&gt; queue = <span class="built_in">new</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素入队 */</span></span><br><span class="line">queue.<span class="built_in">Enqueue</span>(<span class="number">1</span>);</span><br><span class="line">queue.<span class="built_in">Enqueue</span>(<span class="number">3</span>);</span><br><span class="line">queue.<span class="built_in">Enqueue</span>(<span class="number">2</span>);</span><br><span class="line">queue.<span class="built_in">Enqueue</span>(<span class="number">5</span>);</span><br><span class="line">queue.<span class="built_in">Enqueue</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问队首元素 */</span></span><br><span class="line"><span class="type">int</span> peek = queue.<span class="built_in">Peek</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素出队 */</span></span><br><span class="line"><span class="type">int</span> pop = queue.<span class="built_in">Dequeue</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取队列的长度 */</span></span><br><span class="line"><span class="type">int</span> size = queue.Count;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断队列是否为空 */</span></span><br><span class="line"><span class="type">bool</span> isEmpty = queue.Count == <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-5"><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化队列 */</span></span><br><span class="line"><span class="comment">// JavaScript 没有内置的队列，可以把 Array 当作队列来使用</span></span><br><span class="line"><span class="type">const</span> queue = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素入队 */</span></span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问队首元素 */</span></span><br><span class="line"><span class="type">const</span> peek = queue[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素出队 */</span></span><br><span class="line"><span class="comment">// 底层是数组，因此 shift() 方法的时间复杂度为 O(n)</span></span><br><span class="line"><span class="type">const</span> pop = queue.<span class="built_in">shift</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取队列的长度 */</span></span><br><span class="line"><span class="type">const</span> size = queue.length;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断队列是否为空 */</span></span><br><span class="line"><span class="type">const</span> empty = queue.length === <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h3 id="双向队列">双向队列</h3>
<div class="tabs" id="初始化代码"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="初始化代码-1">Python</button><button type="button" class="tab " data-href="初始化代码-2">C++</button><button type="button" class="tab " data-href="初始化代码-3">Java</button><button type="button" class="tab " data-href="初始化代码-4">C#</button><button type="button" class="tab " data-href="初始化代码-5">JS</button></ul><div class="tab-contents"><div class="tab-item-content active" id="初始化代码-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化双向队列</span></span><br><span class="line">deque: deque[<span class="built_in">int</span>] = deque()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 元素入队</span></span><br><span class="line">deque.append(<span class="number">2</span>)      <span class="comment"># 添加至队尾</span></span><br><span class="line">deque.append(<span class="number">5</span>)</span><br><span class="line">deque.append(<span class="number">4</span>)</span><br><span class="line">deque.appendleft(<span class="number">3</span>)  <span class="comment"># 添加至队首</span></span><br><span class="line">deque.appendleft(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问元素</span></span><br><span class="line">front: <span class="built_in">int</span> = deque[<span class="number">0</span>]  <span class="comment"># 队首元素</span></span><br><span class="line">rear: <span class="built_in">int</span> = deque[-<span class="number">1</span>]  <span class="comment"># 队尾元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 元素出队</span></span><br><span class="line">pop_front: <span class="built_in">int</span> = deque.popleft()  <span class="comment"># 队首元素出队</span></span><br><span class="line">pop_rear: <span class="built_in">int</span> = deque.pop()       <span class="comment"># 队尾元素出队</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取双向队列的长度</span></span><br><span class="line">size: <span class="built_in">int</span> = <span class="built_in">len</span>(deque)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断双向队列是否为空</span></span><br><span class="line">is_empty: <span class="built_in">bool</span> = <span class="built_in">len</span>(deque) == <span class="number">0</span></span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-2"><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化双向队列 */</span></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; deque;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素入队 */</span></span><br><span class="line">deque.<span class="built_in">push_back</span>(<span class="number">2</span>);   <span class="comment">// 添加至队尾</span></span><br><span class="line">deque.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">deque.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">deque.<span class="built_in">push_front</span>(<span class="number">3</span>);  <span class="comment">// 添加至队首</span></span><br><span class="line">deque.<span class="built_in">push_front</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问元素 */</span></span><br><span class="line"><span class="type">int</span> front = deque.<span class="built_in">front</span>(); <span class="comment">// 队首元素</span></span><br><span class="line"><span class="type">int</span> back = deque.<span class="built_in">back</span>();   <span class="comment">// 队尾元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素出队 */</span></span><br><span class="line">deque.<span class="built_in">pop_front</span>();  <span class="comment">// 队首元素出队</span></span><br><span class="line">deque.<span class="built_in">pop_back</span>();   <span class="comment">// 队尾元素出队</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取双向队列的长度 */</span></span><br><span class="line"><span class="type">int</span> size = deque.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断双向队列是否为空 */</span></span><br><span class="line"><span class="type">bool</span> empty = deque.<span class="built_in">empty</span>();</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-3"><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化双向队列 */</span></span><br><span class="line">Deque&lt;Integer&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素入队 */</span></span><br><span class="line">deque.<span class="built_in">offerLast</span>(<span class="number">2</span>);   <span class="comment">// 添加至队尾</span></span><br><span class="line">deque.<span class="built_in">offerLast</span>(<span class="number">5</span>);</span><br><span class="line">deque.<span class="built_in">offerLast</span>(<span class="number">4</span>);</span><br><span class="line">deque.<span class="built_in">offerFirst</span>(<span class="number">3</span>);  <span class="comment">// 添加至队首</span></span><br><span class="line">deque.<span class="built_in">offerFirst</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问元素 */</span></span><br><span class="line"><span class="type">int</span> peekFirst = deque.<span class="built_in">peekFirst</span>();  <span class="comment">// 队首元素</span></span><br><span class="line"><span class="type">int</span> peekLast = deque.<span class="built_in">peekLast</span>();    <span class="comment">// 队尾元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素出队 */</span></span><br><span class="line"><span class="type">int</span> popFirst = deque.<span class="built_in">pollFirst</span>();  <span class="comment">// 队首元素出队</span></span><br><span class="line"><span class="type">int</span> popLast = deque.<span class="built_in">pollLast</span>();    <span class="comment">// 队尾元素出队</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取双向队列的长度 */</span></span><br><span class="line"><span class="type">int</span> size = deque.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断双向队列是否为空 */</span></span><br><span class="line"><span class="type">boolean</span> isEmpty = deque.<span class="built_in">isEmpty</span>();</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-4"><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化双向队列 */</span></span><br><span class="line"><span class="comment">// 在 C# 中，将链表 LinkedList 看作双向队列来使用</span></span><br><span class="line">LinkedList&lt;<span class="type">int</span>&gt; deque = <span class="built_in">new</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素入队 */</span></span><br><span class="line">deque.<span class="built_in">AddLast</span>(<span class="number">2</span>);   <span class="comment">// 添加至队尾</span></span><br><span class="line">deque.<span class="built_in">AddLast</span>(<span class="number">5</span>);</span><br><span class="line">deque.<span class="built_in">AddLast</span>(<span class="number">4</span>);</span><br><span class="line">deque.<span class="built_in">AddFirst</span>(<span class="number">3</span>);  <span class="comment">// 添加至队首</span></span><br><span class="line">deque.<span class="built_in">AddFirst</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问元素 */</span></span><br><span class="line"><span class="type">int</span> peekFirst = deque.First.Value;  <span class="comment">// 队首元素</span></span><br><span class="line"><span class="type">int</span> peekLast = deque.Last.Value;    <span class="comment">// 队尾元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素出队 */</span></span><br><span class="line">deque.<span class="built_in">RemoveFirst</span>();  <span class="comment">// 队首元素出队</span></span><br><span class="line">deque.<span class="built_in">RemoveLast</span>();   <span class="comment">// 队尾元素出队</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取双向队列的长度 */</span></span><br><span class="line"><span class="type">int</span> size = deque.Count;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断双向队列是否为空 */</span></span><br><span class="line"><span class="type">bool</span> isEmpty = deque.Count == <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-5"><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化双向队列 */</span></span><br><span class="line"><span class="comment">// JavaScript 没有内置的双端队列，只能把 Array 当作双端队列来使用</span></span><br><span class="line"><span class="type">const</span> deque = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素入队 */</span></span><br><span class="line">deque.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">deque.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">deque.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// 请注意，由于是数组，unshift() 方法的时间复杂度为 O(n)</span></span><br><span class="line">deque.<span class="built_in">unshift</span>(<span class="number">3</span>);</span><br><span class="line">deque.<span class="built_in">unshift</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问元素 */</span></span><br><span class="line"><span class="type">const</span> peekFirst = deque[<span class="number">0</span>];</span><br><span class="line"><span class="type">const</span> peekLast = deque[deque.length - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素出队 */</span></span><br><span class="line"><span class="comment">// 请注意，由于是数组，shift() 方法的时间复杂度为 O(n)</span></span><br><span class="line"><span class="type">const</span> popFront = deque.<span class="built_in">shift</span>();</span><br><span class="line"><span class="type">const</span> popBack = deque.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取双向队列的长度 */</span></span><br><span class="line"><span class="type">const</span> size = deque.length;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断双向队列是否为空 */</span></span><br><span class="line"><span class="type">const</span> isEmpty = size === <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h2 id="算法锻炼">算法锻炼</h2>
<h3 id="最小栈"><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/illustration-of-algorithm/7f65om/">最小栈</a></h3>
<blockquote>
<p>请你设计一个 最小栈 。它提供 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在{ % u 常数时间 %} 内检索到最小元素的栈。</p>
</blockquote>
<blockquote>
<p>输入：<br>
[“MinStack”,“push”,“push”,“push”,“getMin”,“pop”,“top”,“getMin”]<br>
[[],[-2],[2],[-3],[],[],[],[]]</p>
</blockquote>
<blockquote>
<p>输出：<br>
[null,null,null,null,-3,null,2,-2]</p>
</blockquote>
<blockquote>
<p>解释：<br>
MinStack minStack = new MinStack();<br>
minStack.push(-2);<br>
minStack.push(2);<br>
minStack.push(-3);<br>
minStack.getMin();   --&gt; 返回 -3.<br>
minStack.pop();<br>
minStack.top();      --&gt; 返回 2.<br>
minStack.getMin();   --&gt; 返回 -2.</p>
</blockquote>
<p>本题很明显是要使用栈来实现，但是难点在于如何在常数时间内获取堆栈中的最小元素。<br>
试想一下：当我们设定一个<code>min</code>去记录每次压栈元素的最小值，貌似这种方法是可行的。但是一旦出栈元素等于我们的<code>min</code>时，我们便会失去最小值。也就是说我们需要多次记录最小值，也就是拥有可以回退的功能。<br>
那好，现在定义两个栈<code>A,B</code>。一个用来正常记录数据，一个用来记录最小值。<br>
<code>A</code> 中压入 <code>-2</code>，此时<code>B</code>为空，我们也将其压入，<code>B</code>也有元素<code>-2</code><br>
接着<code>A</code>压入<code>2</code>，<code>2</code>大于<code>B</code>中的栈顶元素<code>-2</code>，不压入。<br>
那么<code>A: -2 2</code>  <code> B : -2</code>(右侧为栈顶)。<br>
现在压入<code>-3</code>，<code>-3</code>小于<code>B</code>栈顶元素，压栈。<br>
那么<code>A: -2 2 -3</code>  <code>  B : -2 -3</code>(右侧为栈顶)。<br>
输出最小值，不就是<code>B</code>的栈顶元素吗，如若我们弹出<code>-3</code>，因为<code>-3</code>与<code>B</code>栈顶元素相同，所以<code>B</code>也要弹出栈顶元素。那么此时最小值就是<code>-2</code>。如此类推，便完成此题。</p>
<p>java代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; A,B;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span>()</span> &#123;</span><br><span class="line">        A = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        B = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span>(<span class="params"><span class="built_in">int</span> x</span>)</span> &#123;</span><br><span class="line">        A.push(x);</span><br><span class="line">        <span class="keyword">if</span>(B.isEmpty())B.push(x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(B.peek()&gt;=x)B.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(A.pop().<span class="keyword">equals</span>(B.peek())&amp;&amp;!B.isEmpty())B.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">top</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> A.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">getMin</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> B.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/illustration-of-algorithm/7fg4x5/">类似题</a></p>
<h3 id="数据流中的中位数"><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/illustration-of-algorithm/7fzkf6/">数据流中的中位数</a></h3>
<blockquote>
<p>输入：<br>
[“MedianFinder”,“addNum”,“addNum”,“findMedian”,“addNum”,“findMedian”]<br>
[[],[1],[2],[],[3],[]]<br>
输出：[null,null,null,1.50000,null,2.00000]</p>
</blockquote>
<ul>
<li>知识点：<code>Java</code>中优先队列用<code>PriorityQueue</code>表示，底层用堆（heap）实现，在优先队列中，任何时刻队首元素都是当前队列中优先级最高（小根堆，默认）或最低（大根堆）的元素。每次出队或入队后，会自动调整结构，始终保证队首元素优先级最高。入队、出队优先级均为 $log_2n$。<br>
优先队列代码：</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> Test &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        // 默认小根堆</span><br><span class="line">        PriorityQueue&lt;<span class="type">Integer</span>&gt; pq1 = <span class="built_in">new</span> PriorityQueue&lt;<span class="type">Integer</span>&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            pq1.<span class="keyword">add</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">System</span>.<span class="keyword">out</span>.print(pq1.poll() + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println();</span><br><span class="line">        // 大根堆实现</span><br><span class="line">        PriorityQueue&lt;<span class="type">Integer</span>&gt; pq2 = <span class="built_in">new</span> PriorityQueue&lt;<span class="type">Integer</span>&gt;((x,y)-&gt;y-x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            pq2.<span class="keyword">add</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">System</span>.<span class="keyword">out</span>.print(pq2.poll() + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解题思路： 本题关键在于如何将数据有序化。通过优先队列即可完成。<br>
我们将一组数据按照大小堆的形式存放。 A中存放大数，B中存放小数。但是我们只能保证一侧有序化，如何确保插入元素在全局上有序呢。</p>
<blockquote>
<p>假设插入数字 <code>num</code> 遇到情况 <code>1</code>. 。由于 <code>num</code> 可能属于 “较小的一半” （即属于 <code>B</code> ），因此不能将 <code>nums</code> 直接插入至 <code>A</code> 。而应先将 <code>num</code> 插入至 <code>B</code> ，再将<code>B</code> 堆顶元素插入至 <code>A</code> 。这样就可以始终保<code>A </code>保存较大一半、 <code>B</code> 保存较小一半。(优先队列会自动完成有序化)</p>
</blockquote>
<p>java代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt;A,B;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span>()</span> &#123;</span><br><span class="line">        A = <span class="keyword">new</span> PriorityQueue&lt;&gt;();<span class="comment">//小顶堆</span></span><br><span class="line">        B = <span class="keyword">new</span> PriorityQueue&lt;&gt;((x,y)-&gt;(y-x));<span class="comment">//大顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span>(<span class="params"><span class="built_in">int</span> num</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(A.size()!=B.size())&#123;</span><br><span class="line">            A.<span class="keyword">add</span>(num);</span><br><span class="line">            B.<span class="keyword">add</span>(A.poll());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            B.<span class="keyword">add</span>(num);</span><br><span class="line">            A.<span class="keyword">add</span>(B.poll());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">findMedian</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> A.size() != B.size()?A.peek():(A.peek()+B.peek())/<span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="哈希表">哈希表</h1>
<p>「哈希表 hash table」，又称「散列表」，它通过建立键 key 与值 value 之间的映射，实现高效的元素查询。具体而言，我们向哈希表中输入一个键 key ，则可以在 $O(1)$时间内获取对应的值 value 。</p>
<p><em><strong>通常情况下哈希函数的输入空间远大于输出空间</strong></em>，因此理论上哈希冲突是不可避免的。比如，输入空间为全体整数，输出空间为数组容量大小，则必然有多个整数映射至同一桶索引。</p>
<p>哈希冲突会导致查询结果错误，严重影响哈希表的可用性。为了解决该问题，每当遇到哈希冲突时，我们就进行哈希表扩容，直至冲突消失为止。此方法简单粗暴且有效，但效率太低，因为哈希表扩容需要进行大量的数据搬运与哈希值计算。为了提升效率，我们可以采用以下策略。</p>
<ol>
<li>改良哈希表数据结构，使得哈希表可以在出现哈希冲突时正常工作。</li>
<li>仅在必要时，即当哈希冲突比较严重时，才执行扩容操作。</li>
</ol>
<p>哈希表的结构改良方法主要包括“ <em><strong>链式地址</strong></em> ”和“ <em><strong>开放寻址</strong></em> ”。</p>
<h2 id="链式地址">链式地址</h2>
<p>基于链式地址实现的哈希表的操作方法发生了以下变化。</p>
<ul>
<li>查询元素：输入 key ，经过哈希函数得到桶索引，即可访问链表头节点，然后遍历链表并对比 key 以查找目标键值对。</li>
<li>添加元素：首先通过哈希函数访问链表头节点，然后将节点（键值对）添加到链表中。</li>
<li>删除元素：根据哈希函数的结果访问链表头部，接着遍历链表以查找目标节点并将其删除。</li>
</ul>
<p>链式地址存在以下局限性。</p>
<ul>
<li>占用空间增大：链表包含节点指针，它相比数组更加耗费内存空间。</li>
<li>查询效率降低：因为需要线性遍历链表来查找对应元素。</li>
</ul>
<div class="tabs" id="初始化代码"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="初始化代码-1">Python</button><button type="button" class="tab " data-href="初始化代码-2">C++</button><button type="button" class="tab " data-href="初始化代码-3">Java</button><button type="button" class="tab " data-href="初始化代码-4">C#</button><button type="button" class="tab " data-href="初始化代码-5">JS</button></ul><div class="tab-contents"><div class="tab-item-content active" id="初始化代码-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HashMapChaining</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;链式地址哈希表&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;构造方法&quot;&quot;&quot;</span></span><br><span class="line">        self.size = <span class="number">0</span>  <span class="comment"># 键值对数量</span></span><br><span class="line">        self.capacity = <span class="number">4</span>  <span class="comment"># 哈希表容量</span></span><br><span class="line">        self.load_thres = <span class="number">2.0</span> / <span class="number">3.0</span>  <span class="comment"># 触发扩容的负载因子阈值</span></span><br><span class="line">        self.extend_ratio = <span class="number">2</span>  <span class="comment"># 扩容倍数</span></span><br><span class="line">        self.buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self.capacity)]  <span class="comment"># 桶数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hash_func</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;哈希函数&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> key % self.capacity</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">load_factor</span>(<span class="params">self</span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;负载因子&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.size / self.capacity</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span> | <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;查询操作&quot;&quot;&quot;</span></span><br><span class="line">        index = self.hash_func(key)</span><br><span class="line">        bucket = self.buckets[index]</span><br><span class="line">        <span class="comment"># 遍历桶，若找到 key ，则返回对应 val</span></span><br><span class="line">        <span class="keyword">for</span> pair <span class="keyword">in</span> bucket:</span><br><span class="line">            <span class="keyword">if</span> pair.key == key:</span><br><span class="line">                <span class="keyword">return</span> pair.val</span><br><span class="line">        <span class="comment"># 若未找到 key ，则返回 None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key: <span class="built_in">int</span>, val: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;添加操作&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 当负载因子超过阈值时，执行扩容</span></span><br><span class="line">        <span class="keyword">if</span> self.load_factor() &gt; self.load_thres:</span><br><span class="line">            self.extend()</span><br><span class="line">        index = self.hash_func(key)</span><br><span class="line">        bucket = self.buckets[index]</span><br><span class="line">        <span class="comment"># 遍历桶，若遇到指定 key ，则更新对应 val 并返回</span></span><br><span class="line">        <span class="keyword">for</span> pair <span class="keyword">in</span> bucket:</span><br><span class="line">            <span class="keyword">if</span> pair.key == key:</span><br><span class="line">                pair.val = val</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 若无该 key ，则将键值对添加至尾部</span></span><br><span class="line">        pair = Pair(key, val)</span><br><span class="line">        bucket.append(pair)</span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, key: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;删除操作&quot;&quot;&quot;</span></span><br><span class="line">        index = self.hash_func(key)</span><br><span class="line">        bucket = self.buckets[index]</span><br><span class="line">        <span class="comment"># 遍历桶，从中删除键值对</span></span><br><span class="line">        <span class="keyword">for</span> pair <span class="keyword">in</span> bucket:</span><br><span class="line">            <span class="keyword">if</span> pair.key == key:</span><br><span class="line">                bucket.remove(pair)</span><br><span class="line">                self.size -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">extend</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;扩容哈希表&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 暂存原哈希表</span></span><br><span class="line">        buckets = self.buckets</span><br><span class="line">        <span class="comment"># 初始化扩容后的新哈希表</span></span><br><span class="line">        self.capacity *= self.extend_ratio</span><br><span class="line">        self.buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self.capacity)]</span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 将键值对从原哈希表搬运至新哈希表</span></span><br><span class="line">        <span class="keyword">for</span> bucket <span class="keyword">in</span> buckets:</span><br><span class="line">            <span class="keyword">for</span> pair <span class="keyword">in</span> bucket:</span><br><span class="line">                self.put(pair.key, pair.val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;打印哈希表&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> bucket <span class="keyword">in</span> self.buckets:</span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">for</span> pair <span class="keyword">in</span> bucket:</span><br><span class="line">                res.append(<span class="built_in">str</span>(pair.key) + <span class="string">&quot; -&gt; &quot;</span> + pair.val)</span><br><span class="line">            <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-2"><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 链式地址哈希表 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashMapChaining</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size;                       <span class="comment">// 键值对数量</span></span><br><span class="line">    <span class="type">int</span> capacity;                   <span class="comment">// 哈希表容量</span></span><br><span class="line">    <span class="type">double</span> loadThres;               <span class="comment">// 触发扩容的负载因子阈值</span></span><br><span class="line">    <span class="type">int</span> extendRatio;                <span class="comment">// 扩容倍数</span></span><br><span class="line">    vector&lt;vector&lt;Pair *&gt;&gt; buckets; <span class="comment">// 桶数组</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="built_in">HashMapChaining</span>() : <span class="built_in">size</span>(<span class="number">0</span>), <span class="built_in">capacity</span>(<span class="number">4</span>), <span class="built_in">loadThres</span>(<span class="number">2.0</span> / <span class="number">3.0</span>), <span class="built_in">extendRatio</span>(<span class="number">2</span>) &#123;</span><br><span class="line">        buckets.<span class="built_in">resize</span>(capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 析构方法 */</span></span><br><span class="line">    ~<span class="built_in">HashMapChaining</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;bucket : buckets) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Pair *pair : bucket) &#123;</span><br><span class="line">                <span class="comment">// 释放内存</span></span><br><span class="line">                <span class="keyword">delete</span> pair;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 哈希函数 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hashFunc</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 负载因子 */</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">loadFactor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">double</span>)size / (<span class="type">double</span>)capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 查询操作 */</span></span><br><span class="line">    <span class="function">string <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunc</span>(key);</span><br><span class="line">        <span class="comment">// 遍历桶，若找到 key ，则返回对应 val</span></span><br><span class="line">        <span class="keyword">for</span> (Pair *pair : buckets[index]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair-&gt;key == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> pair-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若未找到 key ，则返回空字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加操作 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, string val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当负载因子超过阈值时，执行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">loadFactor</span>() &gt; loadThres) &#123;</span><br><span class="line">            <span class="built_in">extend</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunc</span>(key);</span><br><span class="line">        <span class="comment">// 遍历桶，若遇到指定 key ，则更新对应 val 并返回</span></span><br><span class="line">        <span class="keyword">for</span> (Pair *pair : buckets[index]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair-&gt;key == key) &#123;</span><br><span class="line">                pair-&gt;val = val;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若无该 key ，则将键值对添加至尾部</span></span><br><span class="line">        buckets[index].<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Pair</span>(key, val));</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除操作 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunc</span>(key);</span><br><span class="line">        <span class="keyword">auto</span> &amp;bucket = buckets[index];</span><br><span class="line">        <span class="comment">// 遍历桶，从中删除键值对</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bucket.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket[i]-&gt;key == key) &#123;</span><br><span class="line">                Pair *tmp = bucket[i];</span><br><span class="line">                bucket.<span class="built_in">erase</span>(bucket.<span class="built_in">begin</span>() + i); <span class="comment">// 从中删除键值对</span></span><br><span class="line">                <span class="keyword">delete</span> tmp;                       <span class="comment">// 释放内存</span></span><br><span class="line">                size--;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 扩容哈希表 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">extend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 暂存原哈希表</span></span><br><span class="line">        vector&lt;vector&lt;Pair *&gt;&gt; bucketsTmp = buckets;</span><br><span class="line">        <span class="comment">// 初始化扩容后的新哈希表</span></span><br><span class="line">        capacity *= extendRatio;</span><br><span class="line">        buckets.<span class="built_in">clear</span>();</span><br><span class="line">        buckets.<span class="built_in">resize</span>(capacity);</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 将键值对从原哈希表搬运至新哈希表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;bucket : bucketsTmp) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Pair *pair : bucket) &#123;</span><br><span class="line">                <span class="built_in">put</span>(pair-&gt;key, pair-&gt;val);</span><br><span class="line">                <span class="comment">// 释放内存</span></span><br><span class="line">                <span class="keyword">delete</span> pair;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印哈希表 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;bucket : buckets) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;[&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (Pair *pair : bucket) &#123;</span><br><span class="line">                cout &lt;&lt; pair-&gt;key &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; pair-&gt;val &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;]\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-3"><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 链式地址哈希表 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashMapChaining</span> &#123;</span><br><span class="line">    <span class="type">int</span> size; <span class="comment">// 键值对数量</span></span><br><span class="line">    <span class="type">int</span> capacity; <span class="comment">// 哈希表容量</span></span><br><span class="line">    <span class="type">double</span> loadThres; <span class="comment">// 触发扩容的负载因子阈值</span></span><br><span class="line">    <span class="type">int</span> extendRatio; <span class="comment">// 扩容倍数</span></span><br><span class="line">    List&lt;List&lt;Pair&gt;&gt; buckets; <span class="comment">// 桶数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMapChaining</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        capacity = <span class="number">4</span>;</span><br><span class="line">        loadThres = <span class="number">2.0</span> / <span class="number">3.0</span>;</span><br><span class="line">        extendRatio = <span class="number">2</span>;</span><br><span class="line">        buckets = <span class="keyword">new</span> ArrayList&lt;&gt;(capacity);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line">            buckets.<span class="built_in">add</span>(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 哈希函数 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hashFunc</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 负载因子 */</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">loadFactor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">double</span>) size / capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 查询操作 */</span></span><br><span class="line">    <span class="function"><span class="type">String</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunc</span>(key);</span><br><span class="line">        List&lt;Pair&gt; bucket = buckets.<span class="built_in">get</span>(index);</span><br><span class="line">        <span class="comment">// 遍历桶，若找到 key ，则返回对应 val</span></span><br><span class="line">        <span class="keyword">for</span> (Pair pair : bucket) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair.key == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> pair.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若未找到 key ，则返回 null</span></span><br><span class="line">        <span class="keyword">return</span> null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加操作 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">String</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当负载因子超过阈值时，执行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">loadFactor</span>() &gt; loadThres) &#123;</span><br><span class="line">            <span class="built_in">extend</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunc</span>(key);</span><br><span class="line">        List&lt;Pair&gt; bucket = buckets.<span class="built_in">get</span>(index);</span><br><span class="line">        <span class="comment">// 遍历桶，若遇到指定 key ，则更新对应 val 并返回</span></span><br><span class="line">        <span class="keyword">for</span> (Pair pair : bucket) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair.key == key) &#123;</span><br><span class="line">                pair.val = val;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若无该 key ，则将键值对添加至尾部</span></span><br><span class="line">        Pair pair = <span class="keyword">new</span> <span class="built_in">Pair</span>(key, val);</span><br><span class="line">        bucket.<span class="built_in">add</span>(pair);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除操作 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunc</span>(key);</span><br><span class="line">        List&lt;Pair&gt; bucket = buckets.<span class="built_in">get</span>(index);</span><br><span class="line">        <span class="comment">// 遍历桶，从中删除键值对</span></span><br><span class="line">        <span class="keyword">for</span> (Pair pair : bucket) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair.key == key) &#123;</span><br><span class="line">                bucket.<span class="built_in">remove</span>(pair);</span><br><span class="line">                size--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 扩容哈希表 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">extend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 暂存原哈希表</span></span><br><span class="line">        List&lt;List&lt;Pair&gt;&gt; bucketsTmp = buckets;</span><br><span class="line">        <span class="comment">// 初始化扩容后的新哈希表</span></span><br><span class="line">        capacity *= extendRatio;</span><br><span class="line">        buckets = <span class="keyword">new</span> ArrayList&lt;&gt;(capacity);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line">            buckets.<span class="built_in">add</span>(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 将键值对从原哈希表搬运至新哈希表</span></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Pair&gt; bucket : bucketsTmp) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Pair pair : bucket) &#123;</span><br><span class="line">                <span class="built_in">put</span>(pair.key, pair.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印哈希表 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Pair&gt; bucket : buckets) &#123;</span><br><span class="line">            List&lt;<span class="type">String</span>&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (Pair pair : bucket) &#123;</span><br><span class="line">                res.<span class="built_in">add</span>(pair.key + <span class="string">&quot; -&gt; &quot;</span> + pair.val);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.<span class="built_in">println</span>(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-4"><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 链式地址哈希表 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">HashMapChaining</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> size; <span class="comment">// 键值对数量</span></span><br><span class="line">    <span class="built_in">int</span> capacity; <span class="comment">// 哈希表容量</span></span><br><span class="line">    <span class="built_in">double</span> loadThres; <span class="comment">// 触发扩容的负载因子阈值</span></span><br><span class="line">    <span class="built_in">int</span> extendRatio; <span class="comment">// 扩容倍数</span></span><br><span class="line">    List&lt;List&lt;Pair&gt;&gt; buckets; <span class="comment">// 桶数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMapChaining</span>()</span> &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        capacity = <span class="number">4</span>;</span><br><span class="line">        loadThres = <span class="number">2.0</span> / <span class="number">3.0</span>;</span><br><span class="line">        extendRatio = <span class="number">2</span>;</span><br><span class="line">        buckets = <span class="keyword">new</span> List&lt;List&lt;Pair&gt;&gt;(capacity);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line">            buckets.Add([]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 哈希函数 */</span></span><br><span class="line">    <span class="function"><span class="built_in">int</span> <span class="title">HashFunc</span>(<span class="params"><span class="built_in">int</span> key</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> key % capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 负载因子 */</span></span><br><span class="line">    <span class="function"><span class="built_in">double</span> <span class="title">LoadFactor</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">double</span>)size / capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 查询操作 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span>? Get(<span class="built_in">int</span> key) &#123;</span><br><span class="line">        <span class="built_in">int</span> index = HashFunc(key);</span><br><span class="line">        <span class="comment">// 遍历桶，若找到 key ，则返回对应 val</span></span><br><span class="line">        <span class="keyword">foreach</span> (Pair pair <span class="keyword">in</span> buckets[index]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair.key == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> pair.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若未找到 key ，则返回 null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加操作 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Put</span>(<span class="params"><span class="built_in">int</span> key, <span class="built_in">string</span> val</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 当负载因子超过阈值时，执行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (LoadFactor() &gt; loadThres) &#123;</span><br><span class="line">            Extend();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> index = HashFunc(key);</span><br><span class="line">        <span class="comment">// 遍历桶，若遇到指定 key ，则更新对应 val 并返回</span></span><br><span class="line">        <span class="keyword">foreach</span> (Pair pair <span class="keyword">in</span> buckets[index]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair.key == key) &#123;</span><br><span class="line">                pair.val = val;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若无该 key ，则将键值对添加至尾部</span></span><br><span class="line">        buckets[index].Add(<span class="keyword">new</span> Pair(key, val));</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除操作 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Remove</span>(<span class="params"><span class="built_in">int</span> key</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> index = HashFunc(key);</span><br><span class="line">        <span class="comment">// 遍历桶，从中删除键值对</span></span><br><span class="line">        <span class="keyword">foreach</span> (Pair pair <span class="keyword">in</span> buckets[index].ToList()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair.key == key) &#123;</span><br><span class="line">                buckets[index].Remove(pair);</span><br><span class="line">                size--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 扩容哈希表 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Extend</span>()</span> &#123;</span><br><span class="line">        <span class="comment">// 暂存原哈希表</span></span><br><span class="line">        List&lt;List&lt;Pair&gt;&gt; bucketsTmp = buckets;</span><br><span class="line">        <span class="comment">// 初始化扩容后的新哈希表</span></span><br><span class="line">        capacity *= extendRatio;</span><br><span class="line">        buckets = <span class="keyword">new</span> List&lt;List&lt;Pair&gt;&gt;(capacity);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line">            buckets.Add([]);</span><br><span class="line">        &#125;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 将键值对从原哈希表搬运至新哈希表</span></span><br><span class="line">        <span class="keyword">foreach</span> (List&lt;Pair&gt; bucket <span class="keyword">in</span> bucketsTmp) &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (Pair pair <span class="keyword">in</span> bucket) &#123;</span><br><span class="line">                Put(pair.key, pair.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印哈希表 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Print</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (List&lt;Pair&gt; bucket <span class="keyword">in</span> buckets) &#123;</span><br><span class="line">            List&lt;<span class="built_in">string</span>&gt; res = [];</span><br><span class="line">            <span class="keyword">foreach</span> (Pair pair <span class="keyword">in</span> bucket) &#123;</span><br><span class="line">                res.Add(pair.key + <span class="string">&quot; -&gt; &quot;</span> + pair.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="built_in">string</span> kv <span class="keyword">in</span> res) &#123;</span><br><span class="line">                Console.WriteLine(kv);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-5"><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 链式地址哈希表 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashMapChaining</span> &#123;</span><br><span class="line">    #size; <span class="comment">// 键值对数量</span></span><br><span class="line">    #capacity; <span class="comment">// 哈希表容量</span></span><br><span class="line">    #loadThres; <span class="comment">// 触发扩容的负载因子阈值</span></span><br><span class="line">    #extendRatio; <span class="comment">// 扩容倍数</span></span><br><span class="line">    #buckets; <span class="comment">// 桶数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.#size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.#capacity = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">this</span>.#loadThres = <span class="number">2.0</span> / <span class="number">3.0</span>;</span><br><span class="line">        <span class="keyword">this</span>.#extendRatio = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">this</span>.#buckets = new Array(<span class="keyword">this</span>.#capacity).fill(<span class="literal">null</span>).map((x) =&gt; []);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 哈希函数 */</span></span><br><span class="line">    #hashFunc(key) &#123;</span><br><span class="line">        <span class="keyword">return</span> key % <span class="keyword">this</span>.#capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 负载因子 */</span></span><br><span class="line">    #loadFactor() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.#size / <span class="keyword">this</span>.#capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 查询操作 */</span></span><br><span class="line">    <span class="keyword">get</span>(key) &#123;</span><br><span class="line">        <span class="keyword">const</span> index = <span class="keyword">this</span>.#hashFunc(key);</span><br><span class="line">        <span class="keyword">const</span> bucket = <span class="keyword">this</span>.#buckets[index];</span><br><span class="line">        <span class="comment">// 遍历桶，若找到 key ，则返回对应 val</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> pair of bucket) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair.key === key) &#123;</span><br><span class="line">                <span class="keyword">return</span> pair.<span class="keyword">val</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若未找到 key ，则返回 null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加操作 */</span></span><br><span class="line">    put(key, <span class="keyword">val</span>) &#123;</span><br><span class="line">        <span class="comment">// 当负载因子超过阈值时，执行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.#loadFactor() &gt; <span class="keyword">this</span>.#loadThres) &#123;</span><br><span class="line">            <span class="keyword">this</span>.#extend();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> index = <span class="keyword">this</span>.#hashFunc(key);</span><br><span class="line">        <span class="keyword">const</span> bucket = <span class="keyword">this</span>.#buckets[index];</span><br><span class="line">        <span class="comment">// 遍历桶，若遇到指定 key ，则更新对应 val 并返回</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> pair of bucket) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair.key === key) &#123;</span><br><span class="line">                pair.<span class="keyword">val</span> = <span class="keyword">val</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若无该 key ，则将键值对添加至尾部</span></span><br><span class="line">        <span class="keyword">const</span> pair = new Pair(key, <span class="keyword">val</span>);</span><br><span class="line">        bucket.push(pair);</span><br><span class="line">        <span class="keyword">this</span>.#size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除操作 */</span></span><br><span class="line">    remove(key) &#123;</span><br><span class="line">        <span class="keyword">const</span> index = <span class="keyword">this</span>.#hashFunc(key);</span><br><span class="line">        let bucket = <span class="keyword">this</span>.#buckets[index];</span><br><span class="line">        <span class="comment">// 遍历桶，从中删除键值对</span></span><br><span class="line">        <span class="keyword">for</span> (let i = <span class="number">0</span>; i &lt; bucket.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket[i].key === key) &#123;</span><br><span class="line">                bucket.splice(i, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">this</span>.#size--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 扩容哈希表 */</span></span><br><span class="line">    #extend() &#123;</span><br><span class="line">        <span class="comment">// 暂存原哈希表</span></span><br><span class="line">        <span class="keyword">const</span> bucketsTmp = <span class="keyword">this</span>.#buckets;</span><br><span class="line">        <span class="comment">// 初始化扩容后的新哈希表</span></span><br><span class="line">        <span class="keyword">this</span>.#capacity *= <span class="keyword">this</span>.#extendRatio;</span><br><span class="line">        <span class="keyword">this</span>.#buckets = new Array(<span class="keyword">this</span>.#capacity).fill(<span class="literal">null</span>).map((x) =&gt; []);</span><br><span class="line">        <span class="keyword">this</span>.#size = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 将键值对从原哈希表搬运至新哈希表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> bucket of bucketsTmp) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> pair of bucket) &#123;</span><br><span class="line">                <span class="keyword">this</span>.put(pair.key, pair.<span class="keyword">val</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印哈希表 */</span></span><br><span class="line">    print() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> bucket of <span class="keyword">this</span>.#buckets) &#123;</span><br><span class="line">            let res = [];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> pair of bucket) &#123;</span><br><span class="line">                res.push(pair.key + <span class="string">&#x27; -&gt; &#x27;</span> + pair.<span class="keyword">val</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            console.log(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<p>当链表很长时，查询效率$O(n)$很差。此时可以将链表转换为“AVL 树”或“红黑树”，从而将查询操作的时间复杂度优化至$O(log n)$</p>
<h2 id="开放寻址">开放寻址</h2>
<h3 id="线性探测">线性探测</h3>
<p>线性探测采用固定步长的线性搜索来进行探测，其操作方法与普通哈希表有所不同。</p>
<ul>
<li>插入元素：通过哈希函数计算桶索引，若发现桶内已有元素，则从冲突位置向后线性遍历（步长通常为$1$），直至找到空桶，将元素插入其中。</li>
<li>查找元素：若发现哈希冲突，则使用相同步长向后进行线性遍历，直到找到对应元素，返回 <code>value</code> 即可；如果遇到空桶，说明目标元素不在哈希表中，返回 <code>None</code> 。</li>
</ul>
<p>线性探测容易产生“聚集现象”。具体来说，数组中连续被占用的位置越长，这些连续位置发生哈希冲突的可能性越大，从而进一步促使该位置的聚堆生长，形成恶性循环，最终导致增删查改操作效率劣化。</p>
<p>值得注意的是，我们不能在开放寻址哈希表中直接删除元素。这是因为删除元素会在数组内产生一个空桶 <code>None</code> ，而当查询元素时，线性探测到该空桶就会返回，因此在该空桶之下的元素都无法再被访问到，程序可能误判这些元素不存在。</p>
<p>为了解决该问题，我们可以采用「懒删除 lazy deletion」机制：它不直接从哈希表中移除元素，而是利用一个常量 TOMBSTONE 来标记这个桶。在该机制下，None 和 TOMBSTONE 都代表空桶，都可以放置键值对。但不同的是，线性探测到 TOMBSTONE 时应该继续遍历，因为其之下可能还存在键值对。</p>
<p>然而，懒删除可能会加速哈希表的性能退化。这是因为每次删除操作都会产生一个删除标记，随着 TOMBSTONE 的增加，搜索时间也会增加，因为线性探测可能需要跳过多个 TOMBSTONE 才能找到目标元素。</p>
<p>为此，考虑在线性探测中记录遇到的首个 TOMBSTONE 的索引，并将搜索到的目标元素与该 TOMBSTONE 交换位置。这样做的好处是当每次查询或添加元素时，元素会被移动至距离理想位置（探测起始点）更近的桶，从而优化查询效率。</p>
<div class="tabs" id="初始化代码"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="初始化代码-1">Python</button><button type="button" class="tab " data-href="初始化代码-2">C++</button><button type="button" class="tab " data-href="初始化代码-3">Java</button><button type="button" class="tab " data-href="初始化代码-4">C#</button><button type="button" class="tab " data-href="初始化代码-5">JS</button></ul><div class="tab-contents"><div class="tab-item-content active" id="初始化代码-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HashMapOpenAddressing</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;开放寻址哈希表&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;构造方法&quot;&quot;&quot;</span></span><br><span class="line">        self.size = <span class="number">0</span>  <span class="comment"># 键值对数量</span></span><br><span class="line">        self.capacity = <span class="number">4</span>  <span class="comment"># 哈希表容量</span></span><br><span class="line">        self.load_thres = <span class="number">2.0</span> / <span class="number">3.0</span>  <span class="comment"># 触发扩容的负载因子阈值</span></span><br><span class="line">        self.extend_ratio = <span class="number">2</span>  <span class="comment"># 扩容倍数</span></span><br><span class="line">        self.buckets: <span class="built_in">list</span>[Pair | <span class="literal">None</span>] = [<span class="literal">None</span>] * self.capacity  <span class="comment"># 桶数组</span></span><br><span class="line">        self.TOMBSTONE = Pair(-<span class="number">1</span>, <span class="string">&quot;-1&quot;</span>)  <span class="comment"># 删除标记</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hash_func</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;哈希函数&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> key % self.capacity</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">load_factor</span>(<span class="params">self</span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;负载因子&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.size / self.capacity</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_bucket</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;搜索 key 对应的桶索引&quot;&quot;&quot;</span></span><br><span class="line">        index = self.hash_func(key)</span><br><span class="line">        first_tombstone = -<span class="number">1</span></span><br><span class="line">        <span class="comment"># 线性探测，当遇到空桶时跳出</span></span><br><span class="line">        <span class="keyword">while</span> self.buckets[index] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 若遇到 key ，返回对应的桶索引</span></span><br><span class="line">            <span class="keyword">if</span> self.buckets[index].key == key:</span><br><span class="line">                <span class="comment"># 若之前遇到了删除标记，则将键值对移动至该索引处</span></span><br><span class="line">                <span class="keyword">if</span> first_tombstone != -<span class="number">1</span>:</span><br><span class="line">                    self.buckets[first_tombstone] = self.buckets[index]</span><br><span class="line">                    self.buckets[index] = self.TOMBSTONE</span><br><span class="line">                    <span class="keyword">return</span> first_tombstone  <span class="comment"># 返回移动后的桶索引</span></span><br><span class="line">                <span class="keyword">return</span> index  <span class="comment"># 返回桶索引</span></span><br><span class="line">            <span class="comment"># 记录遇到的首个删除标记</span></span><br><span class="line">            <span class="keyword">if</span> first_tombstone == -<span class="number">1</span> <span class="keyword">and</span> self.buckets[index] <span class="keyword">is</span> self.TOMBSTONE:</span><br><span class="line">                first_tombstone = index</span><br><span class="line">            <span class="comment"># 计算桶索引，越过尾部则返回头部</span></span><br><span class="line">            index = (index + <span class="number">1</span>) % self.capacity</span><br><span class="line">        <span class="comment"># 若 key 不存在，则返回添加点的索引</span></span><br><span class="line">        <span class="keyword">return</span> index <span class="keyword">if</span> first_tombstone == -<span class="number">1</span> <span class="keyword">else</span> first_tombstone</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;查询操作&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 搜索 key 对应的桶索引</span></span><br><span class="line">        index = self.find_bucket(key)</span><br><span class="line">        <span class="comment"># 若找到键值对，则返回对应 val</span></span><br><span class="line">        <span class="keyword">if</span> self.buckets[index] <span class="keyword">not</span> <span class="keyword">in</span> [<span class="literal">None</span>, self.TOMBSTONE]:</span><br><span class="line">            <span class="keyword">return</span> self.buckets[index].val</span><br><span class="line">        <span class="comment"># 若键值对不存在，则返回 None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key: <span class="built_in">int</span>, val: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;添加操作&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 当负载因子超过阈值时，执行扩容</span></span><br><span class="line">        <span class="keyword">if</span> self.load_factor() &gt; self.load_thres:</span><br><span class="line">            self.extend()</span><br><span class="line">        <span class="comment"># 搜索 key 对应的桶索引</span></span><br><span class="line">        index = self.find_bucket(key)</span><br><span class="line">        <span class="comment"># 若找到键值对，则覆盖 val 并返回</span></span><br><span class="line">        <span class="keyword">if</span> self.buckets[index] <span class="keyword">not</span> <span class="keyword">in</span> [<span class="literal">None</span>, self.TOMBSTONE]:</span><br><span class="line">            self.buckets[index].val = val</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 若键值对不存在，则添加该键值对</span></span><br><span class="line">        self.buckets[index] = Pair(key, val)</span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, key: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;删除操作&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 搜索 key 对应的桶索引</span></span><br><span class="line">        index = self.find_bucket(key)</span><br><span class="line">        <span class="comment"># 若找到键值对，则用删除标记覆盖它</span></span><br><span class="line">        <span class="keyword">if</span> self.buckets[index] <span class="keyword">not</span> <span class="keyword">in</span> [<span class="literal">None</span>, self.TOMBSTONE]:</span><br><span class="line">            self.buckets[index] = self.TOMBSTONE</span><br><span class="line">            self.size -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">extend</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;扩容哈希表&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 暂存原哈希表</span></span><br><span class="line">        buckets_tmp = self.buckets</span><br><span class="line">        <span class="comment"># 初始化扩容后的新哈希表</span></span><br><span class="line">        self.capacity *= self.extend_ratio</span><br><span class="line">        self.buckets = [<span class="literal">None</span>] * self.capacity</span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 将键值对从原哈希表搬运至新哈希表</span></span><br><span class="line">        <span class="keyword">for</span> pair <span class="keyword">in</span> buckets_tmp:</span><br><span class="line">            <span class="keyword">if</span> pair <span class="keyword">not</span> <span class="keyword">in</span> [<span class="literal">None</span>, self.TOMBSTONE]:</span><br><span class="line">                self.put(pair.key, pair.val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;打印哈希表&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> pair <span class="keyword">in</span> self.buckets:</span><br><span class="line">            <span class="keyword">if</span> pair <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;None&quot;</span>)</span><br><span class="line">            <span class="keyword">elif</span> pair <span class="keyword">is</span> self.TOMBSTONE:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;TOMBSTONE&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(pair.key, <span class="string">&quot;-&gt;&quot;</span>, pair.val)</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-2"><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 开放寻址哈希表 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashMapOpenAddressing</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size;                             <span class="comment">// 键值对数量</span></span><br><span class="line">    <span class="type">int</span> capacity = <span class="number">4</span>;                     <span class="comment">// 哈希表容量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> loadThres = <span class="number">2.0</span> / <span class="number">3.0</span>;     <span class="comment">// 触发扩容的负载因子阈值</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> extendRatio = <span class="number">2</span>;            <span class="comment">// 扩容倍数</span></span><br><span class="line">    vector&lt;Pair *&gt; buckets;               <span class="comment">// 桶数组</span></span><br><span class="line">    Pair *TOMBSTONE = <span class="keyword">new</span> <span class="built_in">Pair</span>(<span class="number">-1</span>, <span class="string">&quot;-1&quot;</span>); <span class="comment">// 删除标记</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="built_in">HashMapOpenAddressing</span>() : <span class="built_in">size</span>(<span class="number">0</span>), <span class="built_in">buckets</span>(capacity, <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 析构方法 */</span></span><br><span class="line">    ~<span class="built_in">HashMapOpenAddressing</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> (Pair *pair : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair != <span class="literal">nullptr</span> &amp;&amp; pair != TOMBSTONE) &#123;</span><br><span class="line">                <span class="keyword">delete</span> pair;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> TOMBSTONE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 哈希函数 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hashFunc</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 负载因子 */</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">loadFactor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">double</span>)size / capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 搜索 key 对应的桶索引 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBucket</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunc</span>(key);</span><br><span class="line">        <span class="type">int</span> firstTombstone = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 线性探测，当遇到空桶时跳出</span></span><br><span class="line">        <span class="keyword">while</span> (buckets[index] != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// 若遇到 key ，返回对应的桶索引</span></span><br><span class="line">            <span class="keyword">if</span> (buckets[index]-&gt;key == key) &#123;</span><br><span class="line">                <span class="comment">// 若之前遇到了删除标记，则将键值对移动至该索引处</span></span><br><span class="line">                <span class="keyword">if</span> (firstTombstone != <span class="number">-1</span>) &#123;</span><br><span class="line">                    buckets[firstTombstone] = buckets[index];</span><br><span class="line">                    buckets[index] = TOMBSTONE;</span><br><span class="line">                    <span class="keyword">return</span> firstTombstone; <span class="comment">// 返回移动后的桶索引</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index; <span class="comment">// 返回桶索引</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录遇到的首个删除标记</span></span><br><span class="line">            <span class="keyword">if</span> (firstTombstone == <span class="number">-1</span> &amp;&amp; buckets[index] == TOMBSTONE) &#123;</span><br><span class="line">                firstTombstone = index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算桶索引，越过尾部则返回头部</span></span><br><span class="line">            index = (index + <span class="number">1</span>) % capacity;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若 key 不存在，则返回添加点的索引</span></span><br><span class="line">        <span class="keyword">return</span> firstTombstone == <span class="number">-1</span> ? index : firstTombstone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 查询操作 */</span></span><br><span class="line">    <span class="function">string <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 搜索 key 对应的桶索引</span></span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">findBucket</span>(key);</span><br><span class="line">        <span class="comment">// 若找到键值对，则返回对应 val</span></span><br><span class="line">        <span class="keyword">if</span> (buckets[index] != <span class="literal">nullptr</span> &amp;&amp; buckets[index] != TOMBSTONE) &#123;</span><br><span class="line">            <span class="keyword">return</span> buckets[index]-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若键值对不存在，则返回空字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加操作 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, string val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当负载因子超过阈值时，执行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">loadFactor</span>() &gt; loadThres) &#123;</span><br><span class="line">            <span class="built_in">extend</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 搜索 key 对应的桶索引</span></span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">findBucket</span>(key);</span><br><span class="line">        <span class="comment">// 若找到键值对，则覆盖 val 并返回</span></span><br><span class="line">        <span class="keyword">if</span> (buckets[index] != <span class="literal">nullptr</span> &amp;&amp; buckets[index] != TOMBSTONE) &#123;</span><br><span class="line">            buckets[index]-&gt;val = val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若键值对不存在，则添加该键值对</span></span><br><span class="line">        buckets[index] = <span class="keyword">new</span> <span class="built_in">Pair</span>(key, val);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除操作 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 搜索 key 对应的桶索引</span></span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">findBucket</span>(key);</span><br><span class="line">        <span class="comment">// 若找到键值对，则用删除标记覆盖它</span></span><br><span class="line">        <span class="keyword">if</span> (buckets[index] != <span class="literal">nullptr</span> &amp;&amp; buckets[index] != TOMBSTONE) &#123;</span><br><span class="line">            <span class="keyword">delete</span> buckets[index];</span><br><span class="line">            buckets[index] = TOMBSTONE;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 扩容哈希表 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">extend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 暂存原哈希表</span></span><br><span class="line">        vector&lt;Pair *&gt; bucketsTmp = buckets;</span><br><span class="line">        <span class="comment">// 初始化扩容后的新哈希表</span></span><br><span class="line">        capacity *= extendRatio;</span><br><span class="line">        buckets = <span class="built_in">vector</span>&lt;Pair *&gt;(capacity, <span class="literal">nullptr</span>);</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 将键值对从原哈希表搬运至新哈希表</span></span><br><span class="line">        <span class="keyword">for</span> (Pair *pair : bucketsTmp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair != <span class="literal">nullptr</span> &amp;&amp; pair != TOMBSTONE) &#123;</span><br><span class="line">                <span class="built_in">put</span>(pair-&gt;key, pair-&gt;val);</span><br><span class="line">                <span class="keyword">delete</span> pair;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印哈希表 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Pair *pair : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;nullptr&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pair == TOMBSTONE) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;TOMBSTONE&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cout &lt;&lt; pair-&gt;key &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; pair-&gt;val &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-3"><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 开放寻址哈希表 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashMapOpenAddressing</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size; <span class="comment">// 键值对数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity = <span class="number">4</span>; <span class="comment">// 哈希表容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span> loadThres = <span class="number">2.0</span> / <span class="number">3.0</span>; <span class="comment">// 触发扩容的负载因子阈值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> extendRatio = <span class="number">2</span>; <span class="comment">// 扩容倍数</span></span><br><span class="line">    <span class="keyword">private</span> Pair[] buckets; <span class="comment">// 桶数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Pair TOMBSTONE = <span class="keyword">new</span> <span class="built_in">Pair</span>(<span class="number">-1</span>, <span class="string">&quot;-1&quot;</span>); <span class="comment">// 删除标记</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMapOpenAddressing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        buckets = <span class="keyword">new</span> Pair[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 哈希函数 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="type">int</span> <span class="title">hashFunc</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 负载因子 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="type">double</span> <span class="title">loadFactor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">double</span>) size / capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 搜索 key 对应的桶索引 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="type">int</span> <span class="title">findBucket</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunc</span>(key);</span><br><span class="line">        <span class="type">int</span> firstTombstone = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 线性探测，当遇到空桶时跳出</span></span><br><span class="line">        <span class="keyword">while</span> (buckets[index] != null) &#123;</span><br><span class="line">            <span class="comment">// 若遇到 key ，返回对应的桶索引</span></span><br><span class="line">            <span class="keyword">if</span> (buckets[index].key == key) &#123;</span><br><span class="line">                <span class="comment">// 若之前遇到了删除标记，则将键值对移动至该索引处</span></span><br><span class="line">                <span class="keyword">if</span> (firstTombstone != <span class="number">-1</span>) &#123;</span><br><span class="line">                    buckets[firstTombstone] = buckets[index];</span><br><span class="line">                    buckets[index] = TOMBSTONE;</span><br><span class="line">                    <span class="keyword">return</span> firstTombstone; <span class="comment">// 返回移动后的桶索引</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index; <span class="comment">// 返回桶索引</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录遇到的首个删除标记</span></span><br><span class="line">            <span class="keyword">if</span> (firstTombstone == <span class="number">-1</span> &amp;&amp; buckets[index] == TOMBSTONE) &#123;</span><br><span class="line">                firstTombstone = index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算桶索引，越过尾部则返回头部</span></span><br><span class="line">            index = (index + <span class="number">1</span>) % capacity;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若 key 不存在，则返回添加点的索引</span></span><br><span class="line">        <span class="keyword">return</span> firstTombstone == <span class="number">-1</span> ? index : firstTombstone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 查询操作 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">String</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 搜索 key 对应的桶索引</span></span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">findBucket</span>(key);</span><br><span class="line">        <span class="comment">// 若找到键值对，则返回对应 val</span></span><br><span class="line">        <span class="keyword">if</span> (buckets[index] != null &amp;&amp; buckets[index] != TOMBSTONE) &#123;</span><br><span class="line">            <span class="keyword">return</span> buckets[index].val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若键值对不存在，则返回 null</span></span><br><span class="line">        <span class="keyword">return</span> null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加操作 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">String</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当负载因子超过阈值时，执行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">loadFactor</span>() &gt; loadThres) &#123;</span><br><span class="line">            <span class="built_in">extend</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 搜索 key 对应的桶索引</span></span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">findBucket</span>(key);</span><br><span class="line">        <span class="comment">// 若找到键值对，则覆盖 val 并返回</span></span><br><span class="line">        <span class="keyword">if</span> (buckets[index] != null &amp;&amp; buckets[index] != TOMBSTONE) &#123;</span><br><span class="line">            buckets[index].val = val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若键值对不存在，则添加该键值对</span></span><br><span class="line">        buckets[index] = <span class="keyword">new</span> <span class="built_in">Pair</span>(key, val);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除操作 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 搜索 key 对应的桶索引</span></span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">findBucket</span>(key);</span><br><span class="line">        <span class="comment">// 若找到键值对，则用删除标记覆盖它</span></span><br><span class="line">        <span class="keyword">if</span> (buckets[index] != null &amp;&amp; buckets[index] != TOMBSTONE) &#123;</span><br><span class="line">            buckets[index] = TOMBSTONE;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 扩容哈希表 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="type">void</span> <span class="title">extend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 暂存原哈希表</span></span><br><span class="line">        Pair[] bucketsTmp = buckets;</span><br><span class="line">        <span class="comment">// 初始化扩容后的新哈希表</span></span><br><span class="line">        capacity *= extendRatio;</span><br><span class="line">        buckets = <span class="keyword">new</span> Pair[capacity];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 将键值对从原哈希表搬运至新哈希表</span></span><br><span class="line">        <span class="keyword">for</span> (Pair pair : bucketsTmp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair != null &amp;&amp; pair != TOMBSTONE) &#123;</span><br><span class="line">                <span class="built_in">put</span>(pair.key, pair.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印哈希表 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Pair pair : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair == null) &#123;</span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pair == TOMBSTONE) &#123;</span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="string">&quot;TOMBSTONE&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.<span class="built_in">println</span>(pair.key + <span class="string">&quot; -&gt; &quot;</span> + pair.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-4"><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 开放寻址哈希表 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashMapOpenAddressing</span> &#123;</span><br><span class="line">    <span class="type">int</span> size; <span class="comment">// 键值对数量</span></span><br><span class="line">    <span class="type">int</span> capacity = <span class="number">4</span>; <span class="comment">// 哈希表容量</span></span><br><span class="line">    <span class="type">double</span> loadThres = <span class="number">2.0</span> / <span class="number">3.0</span>; <span class="comment">// 触发扩容的负载因子阈值</span></span><br><span class="line">    <span class="type">int</span> extendRatio = <span class="number">2</span>; <span class="comment">// 扩容倍数</span></span><br><span class="line">    Pair[] buckets; <span class="comment">// 桶数组</span></span><br><span class="line">    Pair TOMBSTONE = <span class="built_in">new</span>(<span class="number">-1</span>, <span class="string">&quot;-1&quot;</span>); <span class="comment">// 删除标记</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMapOpenAddressing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        buckets = <span class="keyword">new</span> Pair[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 哈希函数 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">HashFunc</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 负载因子 */</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">LoadFactor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">double</span>)size / capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 搜索 key 对应的桶索引 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">FindBucket</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">HashFunc</span>(key);</span><br><span class="line">        <span class="type">int</span> firstTombstone = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 线性探测，当遇到空桶时跳出</span></span><br><span class="line">        <span class="keyword">while</span> (buckets[index] != null) &#123;</span><br><span class="line">            <span class="comment">// 若遇到 key ，返回对应的桶索引</span></span><br><span class="line">            <span class="keyword">if</span> (buckets[index].key == key) &#123;</span><br><span class="line">                <span class="comment">// 若之前遇到了删除标记，则将键值对移动至该索引处</span></span><br><span class="line">                <span class="keyword">if</span> (firstTombstone != <span class="number">-1</span>) &#123;</span><br><span class="line">                    buckets[firstTombstone] = buckets[index];</span><br><span class="line">                    buckets[index] = TOMBSTONE;</span><br><span class="line">                    <span class="keyword">return</span> firstTombstone; <span class="comment">// 返回移动后的桶索引</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index; <span class="comment">// 返回桶索引</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录遇到的首个删除标记</span></span><br><span class="line">            <span class="keyword">if</span> (firstTombstone == <span class="number">-1</span> &amp;&amp; buckets[index] == TOMBSTONE) &#123;</span><br><span class="line">                firstTombstone = index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算桶索引，越过尾部则返回头部</span></span><br><span class="line">            index = (index + <span class="number">1</span>) % capacity;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若 key 不存在，则返回添加点的索引</span></span><br><span class="line">        <span class="keyword">return</span> firstTombstone == <span class="number">-1</span> ? index : firstTombstone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 查询操作 */</span></span><br><span class="line">    <span class="keyword">public</span> string? <span class="built_in">Get</span>(<span class="type">int</span> key) &#123;</span><br><span class="line">        <span class="comment">// 搜索 key 对应的桶索引</span></span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">FindBucket</span>(key);</span><br><span class="line">        <span class="comment">// 若找到键值对，则返回对应 val</span></span><br><span class="line">        <span class="keyword">if</span> (buckets[index] != null &amp;&amp; buckets[index] != TOMBSTONE) &#123;</span><br><span class="line">            <span class="keyword">return</span> buckets[index].val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若键值对不存在，则返回 null</span></span><br><span class="line">        <span class="keyword">return</span> null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加操作 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">Put</span><span class="params">(<span class="type">int</span> key, string val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当负载因子超过阈值时，执行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">LoadFactor</span>() &gt; loadThres) &#123;</span><br><span class="line">            <span class="built_in">Extend</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 搜索 key 对应的桶索引</span></span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">FindBucket</span>(key);</span><br><span class="line">        <span class="comment">// 若找到键值对，则覆盖 val 并返回</span></span><br><span class="line">        <span class="keyword">if</span> (buckets[index] != null &amp;&amp; buckets[index] != TOMBSTONE) &#123;</span><br><span class="line">            buckets[index].val = val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若键值对不存在，则添加该键值对</span></span><br><span class="line">        buckets[index] = <span class="keyword">new</span> <span class="built_in">Pair</span>(key, val);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除操作 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">Remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 搜索 key 对应的桶索引</span></span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">FindBucket</span>(key);</span><br><span class="line">        <span class="comment">// 若找到键值对，则用删除标记覆盖它</span></span><br><span class="line">        <span class="keyword">if</span> (buckets[index] != null &amp;&amp; buckets[index] != TOMBSTONE) &#123;</span><br><span class="line">            buckets[index] = TOMBSTONE;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 扩容哈希表 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Extend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 暂存原哈希表</span></span><br><span class="line">        Pair[] bucketsTmp = buckets;</span><br><span class="line">        <span class="comment">// 初始化扩容后的新哈希表</span></span><br><span class="line">        capacity *= extendRatio;</span><br><span class="line">        buckets = <span class="keyword">new</span> Pair[capacity];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 将键值对从原哈希表搬运至新哈希表</span></span><br><span class="line">        foreach (Pair pair in bucketsTmp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair != null &amp;&amp; pair != TOMBSTONE) &#123;</span><br><span class="line">                <span class="built_in">Put</span>(pair.key, pair.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印哈希表 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        foreach (Pair pair in buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair == null) &#123;</span><br><span class="line">                <span class="built_in">Console</span>.<span class="built_in">WriteLine</span>(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pair == TOMBSTONE) &#123;</span><br><span class="line">                <span class="built_in">Console</span>.<span class="built_in">WriteLine</span>(<span class="string">&quot;TOMBSTONE&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">Console</span>.<span class="built_in">WriteLine</span>(pair.key + <span class="string">&quot; -&gt; &quot;</span> + pair.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-5"><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 开放寻址哈希表 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashMapOpenAddressing</span> &#123;</span><br><span class="line">    #size; <span class="comment">// 键值对数量</span></span><br><span class="line">    #capacity; <span class="comment">// 哈希表容量</span></span><br><span class="line">    #loadThres; <span class="comment">// 触发扩容的负载因子阈值</span></span><br><span class="line">    #extendRatio; <span class="comment">// 扩容倍数</span></span><br><span class="line">    #buckets; <span class="comment">// 桶数组</span></span><br><span class="line">    #TOMBSTONE; <span class="comment">// 删除标记</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.#size = <span class="number">0</span>; <span class="comment">// 键值对数量</span></span><br><span class="line">        <span class="keyword">this</span>.#capacity = <span class="number">4</span>; <span class="comment">// 哈希表容量</span></span><br><span class="line">        <span class="keyword">this</span>.#loadThres = <span class="number">2.0</span> / <span class="number">3.0</span>; <span class="comment">// 触发扩容的负载因子阈值</span></span><br><span class="line">        <span class="keyword">this</span>.#extendRatio = <span class="number">2</span>; <span class="comment">// 扩容倍数</span></span><br><span class="line">        <span class="keyword">this</span>.#buckets = Array(<span class="keyword">this</span>.#capacity).fill(<span class="literal">null</span>); <span class="comment">// 桶数组</span></span><br><span class="line">        <span class="keyword">this</span>.#TOMBSTONE = new Pair(-<span class="number">1</span>, <span class="string">&#x27;-1&#x27;</span>); <span class="comment">// 删除标记</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 哈希函数 */</span></span><br><span class="line">    #hashFunc(key) &#123;</span><br><span class="line">        <span class="keyword">return</span> key % <span class="keyword">this</span>.#capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 负载因子 */</span></span><br><span class="line">    #loadFactor() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.#size / <span class="keyword">this</span>.#capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 搜索 key 对应的桶索引 */</span></span><br><span class="line">    #findBucket(key) &#123;</span><br><span class="line">        let index = <span class="keyword">this</span>.#hashFunc(key);</span><br><span class="line">        let firstTombstone = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 线性探测，当遇到空桶时跳出</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">this</span>.#buckets[index] !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 若遇到 key ，返回对应的桶索引</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.#buckets[index].key === key) &#123;</span><br><span class="line">                <span class="comment">// 若之前遇到了删除标记，则将键值对移动至该索引处</span></span><br><span class="line">                <span class="keyword">if</span> (firstTombstone !== -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.#buckets[firstTombstone] = <span class="keyword">this</span>.#buckets[index];</span><br><span class="line">                    <span class="keyword">this</span>.#buckets[index] = <span class="keyword">this</span>.#TOMBSTONE;</span><br><span class="line">                    <span class="keyword">return</span> firstTombstone; <span class="comment">// 返回移动后的桶索引</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index; <span class="comment">// 返回桶索引</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录遇到的首个删除标记</span></span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">                firstTombstone === -<span class="number">1</span> &amp;&amp;</span><br><span class="line">                <span class="keyword">this</span>.#buckets[index] === <span class="keyword">this</span>.#TOMBSTONE</span><br><span class="line">            ) &#123;</span><br><span class="line">                firstTombstone = index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算桶索引，越过尾部则返回头部</span></span><br><span class="line">            index = (index + <span class="number">1</span>) % <span class="keyword">this</span>.#capacity;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若 key 不存在，则返回添加点的索引</span></span><br><span class="line">        <span class="keyword">return</span> firstTombstone === -<span class="number">1</span> ? index : firstTombstone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 查询操作 */</span></span><br><span class="line">    <span class="keyword">get</span>(key) &#123;</span><br><span class="line">        <span class="comment">// 搜索 key 对应的桶索引</span></span><br><span class="line">        <span class="keyword">const</span> index = <span class="keyword">this</span>.#findBucket(key);</span><br><span class="line">        <span class="comment">// 若找到键值对，则返回对应 val</span></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="keyword">this</span>.#buckets[index] !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            <span class="keyword">this</span>.#buckets[index] !== <span class="keyword">this</span>.#TOMBSTONE</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.#buckets[index].<span class="keyword">val</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若键值对不存在，则返回 null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加操作 */</span></span><br><span class="line">    put(key, <span class="keyword">val</span>) &#123;</span><br><span class="line">        <span class="comment">// 当负载因子超过阈值时，执行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.#loadFactor() &gt; <span class="keyword">this</span>.#loadThres) &#123;</span><br><span class="line">            <span class="keyword">this</span>.#extend();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 搜索 key 对应的桶索引</span></span><br><span class="line">        <span class="keyword">const</span> index = <span class="keyword">this</span>.#findBucket(key);</span><br><span class="line">        <span class="comment">// 若找到键值对，则覆盖 val 并返回</span></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="keyword">this</span>.#buckets[index] !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            <span class="keyword">this</span>.#buckets[index] !== <span class="keyword">this</span>.#TOMBSTONE</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">this</span>.#buckets[index].<span class="keyword">val</span> = <span class="keyword">val</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若键值对不存在，则添加该键值对</span></span><br><span class="line">        <span class="keyword">this</span>.#buckets[index] = new Pair(key, <span class="keyword">val</span>);</span><br><span class="line">        <span class="keyword">this</span>.#size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除操作 */</span></span><br><span class="line">    remove(key) &#123;</span><br><span class="line">        <span class="comment">// 搜索 key 对应的桶索引</span></span><br><span class="line">        <span class="keyword">const</span> index = <span class="keyword">this</span>.#findBucket(key);</span><br><span class="line">        <span class="comment">// 若找到键值对，则用删除标记覆盖它</span></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="keyword">this</span>.#buckets[index] !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            <span class="keyword">this</span>.#buckets[index] !== <span class="keyword">this</span>.#TOMBSTONE</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">this</span>.#buckets[index] = <span class="keyword">this</span>.#TOMBSTONE;</span><br><span class="line">            <span class="keyword">this</span>.#size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 扩容哈希表 */</span></span><br><span class="line">    #extend() &#123;</span><br><span class="line">        <span class="comment">// 暂存原哈希表</span></span><br><span class="line">        <span class="keyword">const</span> bucketsTmp = <span class="keyword">this</span>.#buckets;</span><br><span class="line">        <span class="comment">// 初始化扩容后的新哈希表</span></span><br><span class="line">        <span class="keyword">this</span>.#capacity *= <span class="keyword">this</span>.#extendRatio;</span><br><span class="line">        <span class="keyword">this</span>.#buckets = Array(<span class="keyword">this</span>.#capacity).fill(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.#size = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 将键值对从原哈希表搬运至新哈希表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> pair of bucketsTmp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair !== <span class="literal">null</span> &amp;&amp; pair !== <span class="keyword">this</span>.#TOMBSTONE) &#123;</span><br><span class="line">                <span class="keyword">this</span>.put(pair.key, pair.<span class="keyword">val</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印哈希表 */</span></span><br><span class="line">    print() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> pair of <span class="keyword">this</span>.#buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair === <span class="literal">null</span>) &#123;</span><br><span class="line">                console.log(<span class="string">&#x27;null&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pair === <span class="keyword">this</span>.#TOMBSTONE) &#123;</span><br><span class="line">                console.log(<span class="string">&#x27;TOMBSTONE&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                console.log(pair.key + <span class="string">&#x27; -&gt; &#x27;</span> + pair.<span class="keyword">val</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h3 id="平方探测">平方探测</h3>
<p>平方探测与线性探测类似，都是开放寻址的常见策略之一。当发生冲突时，平方探测不是简单地跳过一个固定的步数，而是跳过“探测次数的平方”的步数，即$1,4,9,·····$步。</p>
<p>平方探测主要具有以下优势。</p>
<ul>
<li>
<p>平方探测通过跳过探测次数平方的距离，试图缓解线性探测的聚集效应。</p>
</li>
<li>
<p>平方探测会跳过更大的距离来寻找空位置，有助于数据分布得更加均匀。<br>
然而，平方探测并不是完美的。</p>
</li>
<li>
<p>仍然存在聚集现象，即某些位置比其他位置更容易被占用。</p>
</li>
<li>
<p>由于平方的增长，平方探测可能不会探测整个哈希表，这意味着即使哈希表中有空桶，平方探测也可能无法访问到它。</p>
</li>
</ul>
<h3 id="多次哈希">多次哈希</h3>
<p>顾名思义，多次哈希方法使用多个哈希函数$ f_1(x),f_2(x),f_3(x)···$ 进行探测。</p>
<ul>
<li>插入元素：若哈希函数$f_1(x)$ 出现冲突，则尝试 $f_2(x)$，以此类推，直到找到空位后插入元素。</li>
<li>查找元素：在相同的哈希函数顺序下进行查找，直到找到目标元素时返回；若遇到空位或已尝试所有哈希函数，说明哈希表中不存在该元素，则返回 <code>None</code> 。</li>
</ul>
<p>与线性探测相比，多次哈希方法不易产生聚集，但多个哈希函数会带来额外的计算量。</p>
<div class="note warning flat"><p>请注意，开放寻址（线性探测、平方探测和多次哈希）哈希表都存在“不能直接删除元素”的问题。</p>
</div>
<h1 id="二叉树">二叉树</h1>
<p>「二叉树 binary tree」是一种非线性数据结构，代表“祖先”与“后代”之间的派生关系，体现了“一分为二”的分治逻辑。与链表类似，二叉树的基本单元是节点，每个节点包含值、左子节点引用和右子节点引用。每个节点都有两个引用（指针），分别指向「左子节点 left-child node」和「右子节点 right-child node」，该节点被称为这两个子节点的「父节点 parent node」。当给定一个二叉树的节点时，我们将该节点的左子节点及其以下节点形成的树称为该节点的「左子树 left subtree」，同理可得「右子树 right subtree」。<em><strong>在二叉树中，除叶节点外，其他所有节点都包含子节点和非空子树。</strong></em></p>
<ul>
<li>「根节点 root node」：位于二叉树顶层的节点，没有父节点。</li>
<li>「叶节点 leaf node」：没有子节点的节点，其两个指针均指向 None 。</li>
<li>「边 edge」：连接两个节点的线段，即节点引用（指针）。</li>
<li>节点所在的「层 level」：从顶至底递增，根节点所在层为 1 。</li>
<li>节点的「度 degree」：节点的子节点的数量。在二叉树中，度的取值范围是 0、1、2 。</li>
<li>二叉树的「高度 height」：从根节点到最远叶节点所经过的边的数量。</li>
<li>节点的「深度 depth」：从根节点到该节点所经过的边的数量。</li>
<li>节点的「高度 height」：从距离该节点最远的叶节点到该节点所经过的边的数量。</li>
</ul>
<h2 id="常见二叉树类型">常见二叉树类型</h2>
<ul>
<li>
<p>「完美二叉树or满二叉树 perfect binary tree」所有层的节点都被完全填满。在完美二叉树中，叶节点的度为 $0$ ，其余所有节点的度都为$2$；若树的高度为$h$，则节点总数为$2^{h+1}-1$。</p>
</li>
<li>
<p>「完全二叉树 complete binary tree」只有最底层的节点未被填满，且最底层节点尽量靠左填充。</p>
</li>
<li>
<p>「完满二叉树 full binary tree」除了叶节点之外，其余所有节点都有两个子节点。</p>
</li>
<li>
<p>「平衡二叉树 balanced binary tree」中任意节点的左子树和右子树的高度之差的绝对值不超过 1 。</p>
</li>
</ul>
<h2 id="二叉树的遍历">二叉树的遍历</h2>
<ol>
<li>「层序遍历 level-order traversal」从顶部到底部逐层遍历二叉树，并在每一层按照从左到右的顺序访问节点。层序遍历本质上属于「广度优先遍历 breadth-first traversal」，也称「广度优先搜索 breadth-first search, BFS」，它体现了一种“一圈一圈向外扩展”的逐层遍历方式。</li>
</ol>
<div class="tabs" id="初始化代码"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="初始化代码-1">Python</button><button type="button" class="tab " data-href="初始化代码-2">C++</button><button type="button" class="tab " data-href="初始化代码-3">Java</button><button type="button" class="tab " data-href="初始化代码-4">C#</button><button type="button" class="tab " data-href="初始化代码-5">JS</button></ul><div class="tab-contents"><div class="tab-item-content active" id="初始化代码-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">level_order</span>(<span class="params">root: TreeNode | <span class="literal">None</span></span>) -&gt; <span class="built_in">list</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;层序遍历&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 初始化队列，加入根节点</span></span><br><span class="line">    queue: deque[TreeNode] = deque()</span><br><span class="line">    queue.append(root)</span><br><span class="line">    <span class="comment"># 初始化一个列表，用于保存遍历序列</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        node: TreeNode = queue.popleft()  <span class="comment"># 队列出队</span></span><br><span class="line">        res.append(node.val)  <span class="comment"># 保存节点值</span></span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            queue.append(node.left)  <span class="comment"># 左子节点入队</span></span><br><span class="line">        <span class="keyword">if</span> node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            queue.append(node.right)  <span class="comment"># 右子节点入队</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-2"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 层序遍历 */</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">levelOrder</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化队列，加入根节点</span></span><br><span class="line">    queue&lt;TreeNode *&gt; queue;</span><br><span class="line">    queue.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="comment">// 初始化一个列表，用于保存遍历序列</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">while</span> (!queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode *node = queue.<span class="built_in">front</span>();</span><br><span class="line">        queue.<span class="built_in">pop</span>();              <span class="comment">// 队列出队</span></span><br><span class="line">        vec.<span class="built_in">push_back</span>(node-&gt;val); <span class="comment">// 保存节点值</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">            queue.<span class="built_in">push</span>(node-&gt;left); <span class="comment">// 左子节点入队</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">            queue.<span class="built_in">push</span>(node-&gt;right); <span class="comment">// 右子节点入队</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-3"><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 层序遍历 */</span></span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    <span class="comment">// 初始化队列，加入根节点</span></span><br><span class="line">    <span class="built_in">Queue</span>&lt;TreeNode&gt; <span class="built_in">queue</span> = <span class="literal">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="built_in">queue</span>.add(root);</span><br><span class="line">    <span class="comment">// 初始化一个列表，用于保存遍历序列</span></span><br><span class="line">    <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; <span class="built_in">list</span> = <span class="literal">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">queue</span>.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = <span class="built_in">queue</span>.poll(); <span class="comment">// 队列出队</span></span><br><span class="line">        <span class="built_in">list</span>.add(node.val);           <span class="comment">// 保存节点值</span></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="built_in">null</span>)</span><br><span class="line">            <span class="built_in">queue</span>.offer(node.left);   <span class="comment">// 左子节点入队</span></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="built_in">null</span>)</span><br><span class="line">            <span class="built_in">queue</span>.offer(node.right);  <span class="comment">// 右子节点入队</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-4"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 层序遍历 */</span></span><br><span class="line"><span class="function">List&lt;<span class="type">int</span>&gt; <span class="title">LevelOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化队列，加入根节点</span></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="built_in">new</span>();</span><br><span class="line">    queue.<span class="built_in">Enqueue</span>(root);</span><br><span class="line">    <span class="comment">// 初始化一个列表，用于保存遍历序列</span></span><br><span class="line">    List&lt;<span class="type">int</span>&gt; list = [];</span><br><span class="line">    <span class="keyword">while</span> (queue.Count != <span class="number">0</span>) &#123;</span><br><span class="line">        TreeNode node = queue.<span class="built_in">Dequeue</span>(); <span class="comment">// 队列出队</span></span><br><span class="line">        list.<span class="built_in">Add</span>(node.val!.Value);       <span class="comment">// 保存节点值</span></span><br><span class="line">        <span class="keyword">if</span> (node.left != null)</span><br><span class="line">            queue.<span class="built_in">Enqueue</span>(node.left);    <span class="comment">// 左子节点入队</span></span><br><span class="line">        <span class="keyword">if</span> (node.right != null)</span><br><span class="line">            queue.<span class="built_in">Enqueue</span>(node.right);   <span class="comment">// 右子节点入队</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-5"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 层序遍历 */</span></span><br><span class="line"><span class="function">function <span class="title">levelOrder</span><span class="params">(root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化队列，加入根节点</span></span><br><span class="line">    <span class="type">const</span> queue = [root];</span><br><span class="line">    <span class="comment">// 初始化一个列表，用于保存遍历序列</span></span><br><span class="line">    <span class="type">const</span> list = [];</span><br><span class="line">    <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">        let node = queue.<span class="built_in">shift</span>(); <span class="comment">// 队列出队</span></span><br><span class="line">        list.<span class="built_in">push</span>(node.val); <span class="comment">// 保存节点值</span></span><br><span class="line">        <span class="keyword">if</span> (node.left) queue.<span class="built_in">push</span>(node.left); <span class="comment">// 左子节点入队</span></span><br><span class="line">        <span class="keyword">if</span> (node.right) queue.<span class="built_in">push</span>(node.right); <span class="comment">// 右子节点入队</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<ol start="2">
<li>前序、中序和后序遍历都属于「深度优先遍历 depth-first traversal」，也称「深度优先搜索 depth-first search, DFS」，它体现了一种“先走到尽头，再回溯继续”的遍历方式。</li>
</ol>
<div class="tabs" id="初始化代码"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="初始化代码-1">Python</button><button type="button" class="tab " data-href="初始化代码-2">C++</button><button type="button" class="tab " data-href="初始化代码-3">Java</button><button type="button" class="tab " data-href="初始化代码-4">C#</button><button type="button" class="tab " data-href="初始化代码-5">JS</button></ul><div class="tab-contents"><div class="tab-item-content active" id="初始化代码-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pre_order</span>(<span class="params">root: TreeNode | <span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;前序遍历&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 访问优先级：根节点 -&gt; 左子树 -&gt; 右子树</span></span><br><span class="line">    res.append(root.val)</span><br><span class="line">    pre_order(root=root.left)</span><br><span class="line">    pre_order(root=root.right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">in_order</span>(<span class="params">root: TreeNode | <span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;中序遍历&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 访问优先级：左子树 -&gt; 根节点 -&gt; 右子树</span></span><br><span class="line">    in_order(root=root.left)</span><br><span class="line">    res.append(root.val)</span><br><span class="line">    in_order(root=root.right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">post_order</span>(<span class="params">root: TreeNode | <span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;后序遍历&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 访问优先级：左子树 -&gt; 右子树 -&gt; 根节点</span></span><br><span class="line">    post_order(root=root.left)</span><br><span class="line">    post_order(root=root.right)</span><br><span class="line">    res.append(root.val)</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-2"><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 前序遍历 */</span></span><br><span class="line">void <span class="built_in">preOrder</span>(TreeNode *root) &#123;</span><br><span class="line">    if (root == nullptr)</span><br><span class="line">        return;</span><br><span class="line">    <span class="comment">// 访问优先级：根节点 -&gt; 左子树 -&gt; 右子树</span></span><br><span class="line">    vec<span class="selector-class">.push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="built_in">preOrder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">preOrder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中序遍历 */</span></span><br><span class="line">void <span class="built_in">inOrder</span>(TreeNode *root) &#123;</span><br><span class="line">    if (root == nullptr)</span><br><span class="line">        return;</span><br><span class="line">    <span class="comment">// 访问优先级：左子树 -&gt; 根节点 -&gt; 右子树</span></span><br><span class="line">    <span class="built_in">inOrder</span>(root-&gt;left);</span><br><span class="line">    vec<span class="selector-class">.push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="built_in">inOrder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 后序遍历 */</span></span><br><span class="line">void <span class="built_in">postOrder</span>(TreeNode *root) &#123;</span><br><span class="line">    if (root == nullptr)</span><br><span class="line">        return;</span><br><span class="line">    <span class="comment">// 访问优先级：左子树 -&gt; 右子树 -&gt; 根节点</span></span><br><span class="line">    <span class="built_in">postOrder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">postOrder</span>(root-&gt;right);</span><br><span class="line">    vec<span class="selector-class">.push_back</span>(root-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-3"><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 前序遍历 */</span></span><br><span class="line">void <span class="built_in">preOrder</span>(TreeNode root) &#123;</span><br><span class="line">    if (root == null)</span><br><span class="line">        return;</span><br><span class="line">    <span class="comment">// 访问优先级：根节点 -&gt; 左子树 -&gt; 右子树</span></span><br><span class="line">    list<span class="selector-class">.add</span>(root.val);</span><br><span class="line">    <span class="built_in">preOrder</span>(root.left);</span><br><span class="line">    <span class="built_in">preOrder</span>(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中序遍历 */</span></span><br><span class="line">void <span class="built_in">inOrder</span>(TreeNode root) &#123;</span><br><span class="line">    if (root == null)</span><br><span class="line">        return;</span><br><span class="line">    <span class="comment">// 访问优先级：左子树 -&gt; 根节点 -&gt; 右子树</span></span><br><span class="line">    <span class="built_in">inOrder</span>(root.left);</span><br><span class="line">    list<span class="selector-class">.add</span>(root.val);</span><br><span class="line">    <span class="built_in">inOrder</span>(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 后序遍历 */</span></span><br><span class="line">void <span class="built_in">postOrder</span>(TreeNode root) &#123;</span><br><span class="line">    if (root == null)</span><br><span class="line">        return;</span><br><span class="line">    <span class="comment">// 访问优先级：左子树 -&gt; 右子树 -&gt; 根节点</span></span><br><span class="line">    <span class="built_in">postOrder</span>(root.left);</span><br><span class="line">    <span class="built_in">postOrder</span>(root.right);</span><br><span class="line">    list<span class="selector-class">.add</span>(root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-4"><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 前序遍历 */</span></span><br><span class="line">void <span class="built_in">PreOrder</span>(TreeNode? root) &#123;</span><br><span class="line">    if (root == null) return;</span><br><span class="line">    <span class="comment">// 访问优先级：根节点 -&gt; 左子树 -&gt; 右子树</span></span><br><span class="line">    list<span class="selector-class">.Add</span>(root.val!.Value);</span><br><span class="line">    <span class="built_in">PreOrder</span>(root.left);</span><br><span class="line">    <span class="built_in">PreOrder</span>(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中序遍历 */</span></span><br><span class="line">void <span class="built_in">InOrder</span>(TreeNode? root) &#123;</span><br><span class="line">    if (root == null) return;</span><br><span class="line">    <span class="comment">// 访问优先级：左子树 -&gt; 根节点 -&gt; 右子树</span></span><br><span class="line">    <span class="built_in">InOrder</span>(root.left);</span><br><span class="line">    list<span class="selector-class">.Add</span>(root.val!.Value);</span><br><span class="line">    <span class="built_in">InOrder</span>(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 后序遍历 */</span></span><br><span class="line">void <span class="built_in">PostOrder</span>(TreeNode? root) &#123;</span><br><span class="line">    if (root == null) return;</span><br><span class="line">    <span class="comment">// 访问优先级：左子树 -&gt; 右子树 -&gt; 根节点</span></span><br><span class="line">    <span class="built_in">PostOrder</span>(root.left);</span><br><span class="line">    <span class="built_in">PostOrder</span>(root.right);</span><br><span class="line">    list<span class="selector-class">.Add</span>(root.val!.Value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-5"><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 前序遍历 */</span></span><br><span class="line">function <span class="built_in">preOrder</span>(root) &#123;</span><br><span class="line">    if (root === null) return;</span><br><span class="line">    <span class="comment">// 访问优先级：根节点 -&gt; 左子树 -&gt; 右子树</span></span><br><span class="line">    list<span class="selector-class">.push</span>(root.val);</span><br><span class="line">    <span class="built_in">preOrder</span>(root.left);</span><br><span class="line">    <span class="built_in">preOrder</span>(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中序遍历 */</span></span><br><span class="line">function <span class="built_in">inOrder</span>(root) &#123;</span><br><span class="line">    if (root === null) return;</span><br><span class="line">    <span class="comment">// 访问优先级：左子树 -&gt; 根节点 -&gt; 右子树</span></span><br><span class="line">    <span class="built_in">inOrder</span>(root.left);</span><br><span class="line">    list<span class="selector-class">.push</span>(root.val);</span><br><span class="line">    <span class="built_in">inOrder</span>(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 后序遍历 */</span></span><br><span class="line">function <span class="built_in">postOrder</span>(root) &#123;</span><br><span class="line">    if (root === null) return;</span><br><span class="line">    <span class="comment">// 访问优先级：左子树 -&gt; 右子树 -&gt; 根节点</span></span><br><span class="line">    <span class="built_in">postOrder</span>(root.left);</span><br><span class="line">    <span class="built_in">postOrder</span>(root.right);</span><br><span class="line">    list<span class="selector-class">.push</span>(root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h1 id="广度优先遍历">广度优先遍历</h1>
<ul>
<li>
<p>广度优先遍历是一种由近及远的遍历方式，从某个几节点出发，始终优先访问最近的顶点，并一层层向外扩张。</p>
</li>
<li>
<p>广度优先通常使用队列来实现，队列的先入先出的性质和BFS的思想异曲同工。</p>
</li>
</ul>
<ol>
<li>将遍历起始顶点加入队列中开始循环</li>
<li>在每次循环的每轮迭代中，弹出队首顶点并记录访问，然后将该顶点的所以邻接点加入到队尾。</li>
<li>重复2，直到所有顶点被访问完毕。</li>
</ol>
<p>java代码实现：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 广度优先遍历 */</span></span><br><span class="line"><span class="comment">// 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点</span></span><br><span class="line"><span class="keyword">List</span>&lt;Vertex&gt; graphBFS(GraphAdjList <span class="keyword">graph</span>, Vertex startVet) &#123;</span><br><span class="line">    <span class="comment">// 顶点遍历序列</span></span><br><span class="line">    <span class="keyword">List</span>&lt;Vertex&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 哈希表，用于记录已被访问过的顶点</span></span><br><span class="line">    <span class="keyword">Set</span>&lt;Vertex&gt; visited = new HashSet&lt;&gt;();</span><br><span class="line">    visited.add(startVet);</span><br><span class="line">    <span class="comment">// 队列用于实现 BFS</span></span><br><span class="line">    Queue&lt;Vertex&gt; <span class="keyword">que</span> = new LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">que</span>.offer(startVet);</span><br><span class="line">    <span class="comment">// 以顶点 vet 为起点，循环直至访问完所有顶点</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">que</span>.isEmpty()) &#123;</span><br><span class="line">        Vertex vet = <span class="keyword">que</span>.poll(); <span class="comment">// 队首顶点出队</span></span><br><span class="line">        res.add(vet);            <span class="comment">// 记录访问顶点</span></span><br><span class="line">        <span class="comment">// 遍历该顶点的所有邻接顶点</span></span><br><span class="line">        <span class="keyword">for</span> (Vertex adjVet : <span class="keyword">graph</span>.adjList.<span class="built_in">get</span>(vet)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.contains(adjVet))</span><br><span class="line">                <span class="keyword">continue</span>;        <span class="comment">// 跳过已被访问的顶点</span></span><br><span class="line">            <span class="keyword">que</span>.offer(adjVet);   <span class="comment">// 只入队未访问的顶点</span></span><br><span class="line">            visited.add(adjVet); <span class="comment">// 标记该顶点已被访问</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回顶点遍历序列</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note warning flat"><p>广度优先遍历的序列是不唯一的，多个相同的距离的顶点的遍历顺序允许被任意打乱</p>
</div>
<h1 id="深度优先遍历">深度优先遍历</h1>
<ul>
<li>深度优先遍历是一种优先走到底，无路可走再回头的遍历方式。（不撞南墙不回头）<br>
java代码如下：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 深度优先遍历辅助函数 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span>(<span class="params">GraphAdjList graph, <span class="built_in">Set</span>&lt;Vertex&gt; visited, List&lt;Vertex&gt; res, Vertex vet</span>) &#123;</span><br><span class="line">    res.<span class="title function_">add</span>(vet);     <span class="comment">// 记录访问顶点</span></span><br><span class="line">    visited.<span class="title function_">add</span>(vet); <span class="comment">// 标记该顶点已被访问</span></span><br><span class="line">    <span class="comment">// 遍历该顶点的所有邻接顶点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="title class_">Vertex</span> adjVet : graph.<span class="property">adjList</span>.<span class="title function_">get</span>(vet)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited.<span class="title function_">contains</span>(adjVet))</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 跳过已被访问的顶点</span></span><br><span class="line">        <span class="comment">// 递归访问邻接顶点</span></span><br><span class="line">        <span class="title function_">dfs</span>(graph, visited, res, adjVet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 深度优先遍历 */</span></span><br><span class="line"><span class="comment">// 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点</span></span><br><span class="line"><span class="title class_">List</span>&lt;<span class="title class_">Vertex</span>&gt; <span class="title function_">graphDFS</span>(<span class="params">GraphAdjList graph, Vertex startVet</span>) &#123;</span><br><span class="line">    <span class="comment">// 顶点遍历序列</span></span><br><span class="line">    <span class="title class_">List</span>&lt;<span class="title class_">Vertex</span>&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 哈希表，用于记录已被访问过的顶点</span></span><br><span class="line">    <span class="title class_">Set</span>&lt;<span class="title class_">Vertex</span>&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="title function_">dfs</span>(graph, visited, res, startVet);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note warning flat"><p>深度优先遍历的序列也是不唯一的</p>
</div>
<blockquote>
<p>图的广度优先遍历是一种由近及远、层层扩张的搜索方式，通常借助队列实现。<br>
图的深度优先遍历是一种优先走到底、无路可走时再回溯的搜索方式，常基于递归来实现。</p>
</blockquote>
<h1 id="排序算法">排序算法</h1>
<h2 id="桶排序">桶排序</h2>
<ul>
<li>桶排序简单理解就是用一组有序的容器(桶)，将原先无序的数组进行归类。这样按照有序的容器逐个输出，就将原先无序的数组变成有序的数组了。<br>
初始数组： <code>5 5 2 6 6 3 9 7</code><br>
准备有序容器从<code>1-10</code>共<code>10</code>个桶，分别将初始数组元素装入。<br>
有序容器: <code>1</code> <code>2</code> <code>3</code> <code>4</code> <code>5</code> <code>6</code> <code>7</code> <code>8</code> <code>9</code> <code>10</code><br>
装有个数: <code>0</code> <code>1</code> <code>1</code> <code>0</code> <code>2</code> <code>2</code> <code>1</code> <code>0</code> <code>1</code> <code>0</code><br>
现在在按照有序容器的顺序输出(相当于按照容器顺序将桶内的数给拿出去)，就可以达到排序的结果。</li>
</ul>
<p>java代码如下：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        Scanner sc = <span class="built_in">new</span> Scanner(<span class="keyword">System</span>.<span class="keyword">in</span>);</span><br><span class="line">        <span class="type">int</span>[] tong = <span class="built_in">new</span> <span class="type">int</span>[<span class="number">1001</span>];</span><br><span class="line">        <span class="type">int</span> n = sc.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            tong[sc.nextInt()] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tong.length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(tong[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">System</span>.<span class="keyword">out</span>.print(i);</span><br><span class="line">                <span class="keyword">System</span>.<span class="keyword">out</span>.print(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">                tong[i] -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>桶排序的时间复杂度是$O(M+N)$,这是一个很快速的排序算法,但是它特别浪费空间,试想一下如果你的数据范围是在0-2亿，但是你的数组实际上就只有5个数。你要准备的桶的数量是很多的。更进一步来说，当你需要排序的数据出现小数的时候，桶排序是很难做到。</p>
</blockquote>
<h2 id="冒泡排序">冒泡排序</h2>
<ul>
<li>基本思想:每次比较两个相邻的元素，如果它们的顺序错误就交换它们的位置。<br>
代码思路： 你想想假设5个数字排序，你每次冒泡交换位置之后可以确定一个元素的唯一位置，那么当你执行完第4个时，第五个就确定了。所以外层循环为<code>n-1</code>次。内层循环就是为了冒泡而生,交换相邻位置(<code>j</code>和<code>j+1</code>) 这样冒泡排序就完成了。</li>
</ul>
<p>java代码如下：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        Scanner sc = <span class="built_in">new</span> Scanner(<span class="keyword">System</span>.<span class="keyword">in</span>);</span><br><span class="line">        <span class="type">int</span> n = sc.nextInt();</span><br><span class="line">        <span class="type">int</span>[] maopao = <span class="built_in">new</span> <span class="type">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            maopao[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n-i<span class="number">-1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(maopao[j]&lt;maopao[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="type">int</span> tmp = maopao[j+<span class="number">1</span>];</span><br><span class="line">                    maopao[j+<span class="number">1</span>] = maopao[j];</span><br><span class="line">                    maopao[j] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">System</span>.<span class="keyword">out</span>.print(maopao[i]);</span><br><span class="line">            <span class="keyword">System</span>.<span class="keyword">out</span>.print(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>冒泡排序的核心就是这个双层循环，时间复杂度是是 $O(N^2)$,当数据量特别大的时候，这个算法的时间复杂度是很大。</p>
</blockquote>
<h2 id="快速排序">快速排序</h2>
<p>快速排序是基于二分的思想，首先在这个序列中随便找一个数作为基准数M，为了将这个基准数移到某个位置k,使得左边的数都小于等于 M，右边的数都大于等于 M。</p>
<p>例如：“6 1 2 7 9 3 4 5 10 8”两端开始“探测”。先从右往左找一个小于 6 的数，再从左往右找一个大于 6 的数，然后交换它们。这里可以用两个变量 i 和 j，分别指向序列最左边和最右边让哨兵 j 先出动，这一点非常重要。哨兵 j 一步一步地向左挪动（即 j++），直到找到一个小于 6 的数停下来。接下来哨兵 i 再一步一步向右挪动（即 i++），直到找到一个大于 6的数停下来。最后哨兵 j 停在了数字 5 面前，哨兵 i 停在了数字 7 面前。现在交换二者位置。原序列变为 “6 1 2 <span class='p red'>5</span> 9 3 4 <span class='p red'>7</span> 10 8”<br>
第一次交换结束。接下来哨兵 j 继续向左挪动（再次友情提醒，每次必须是哨兵j 先出发）。他发现了 4（比基准数 6 要小，满足要求）之后停了下来。哨兵 i 也继续向右挪动，他发现了 9（比基准数 6 要大，满足要求）之后停了下来。此时再次进行交换，交换之后的序列如下“6 1 2 5 <span class='p red'>4</span> 3 <span class='p red'>9</span> 7 10 8”<br>
第二次交换结束，“探测”继续。哨兵 j 继续向左挪动，他发现了 3（比基准数 6 要小，满足要求）之后又停了下来。哨兵 i 继续向右移动，此时哨兵 i 和哨兵 j 相遇了，哨兵 i 和哨兵 j 都走到 3 面前。说明此时“探测”结束。我们将基准数 6 和 3 进行交换。交换之后的序列如下。“<span class='p red'>3</span> 1 2 5 4 <span class='p red'>6</span> 9 7 10 8 ”<br>
这样我们就得到了一个满足要求的序列，此时以基准数 6 为分界点，6 左边的数都小于等于 6，6右边的数都大于等于 6。“3 1 2 5 4 <mark class="hl-label red">6</mark>  9 7 10 8 ”<br>
对剩下两边重复上面这个过程，就得到了一个有序序列。<br>
变化过程如下:</p>
<p>10<br>
6 1 2 7 9 3 4 5 10 8</p>
<hr>
<p>3 1 2 5 4 6 9 7 10 8<br>
2 1 3 5 4 6 9 7 10 8<br>
1 2 3 5 4 6 9 7 10 8<br>
1 2 3 5 4 6 9 7 10 8<br>
1 2 3 4 5 6 9 7 10 8<br>
1 2 3 4 5 6 9 7 10 8<br>
1 2 3 4 5 6 8 7 9 10<br>
1 2 3 4 5 6 7 8 9 10<br>
1 2 3 4 5 6 7 8 9 10<br>
1 2 3 4 5 6 7 8 9 10</p>
<hr>
<p>java代码如下：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">quicksort</span><span class="params">(<span class="type">int</span>[] quick,<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(left&gt;right)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = left,j = right,tmp=quick[left];</span><br><span class="line">    <span class="comment">//tmp为基准数</span></span><br><span class="line">    <span class="keyword">while</span>(i!=j)&#123;</span><br><span class="line">        <span class="comment">//先右后左</span></span><br><span class="line">        <span class="keyword">while</span>(quick[j]&gt;=tmp &amp;&amp; i&lt;j)j--;</span><br><span class="line">        <span class="keyword">while</span>(quick[i]&lt;=tmp &amp;&amp; i&lt;j)i++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//满足要求就交换位置</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="type">int</span> a = quick[i];</span><br><span class="line">            quick[i] = quick[j];</span><br><span class="line">            quick[j] = a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最终将基准数归位,实际上就是找到了基准数最后的位置。</span></span><br><span class="line">    quick[left] = quick[i];</span><br><span class="line">    quick[i] = tmp;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//现在就相当于一遍完成了。对左右两个序列用相同方法。</span></span><br><span class="line">    <span class="built_in">quicksort</span>(quick,left,i<span class="number">-1</span>);<span class="comment">//左边序列</span></span><br><span class="line">    <span class="built_in">quicksort</span>(quick,i+<span class="number">1</span>,right);<span class="comment">//右边序列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>快速排序之所以比较快，是因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样只能在相邻的数之间进行交换，交换的距离就大得多了。因此总的比较和交换次数就少了，速度自然就提高了。<u>当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的，都是 $O(N^2)$，它的平均时间复杂度为 $O(NlogN)$。</u></p>
</blockquote>
<h2 id="算法优化">算法优化</h2>
<p><em><strong>尾递归：</strong></em></p>
<p>由于普通快速排序每轮选取「子数组最左元素」作为「基准数」，因此在输入数组 <em><strong>完全倒序</strong></em> 时， <code>partition()</code> 的递归深度会达到 <code>N</code> ，即 <em><strong>最差空间复杂度</strong></em> 为 $O(N)$ 。每轮递归时，仅对 <em><strong>较短的子数组</strong></em> 执行哨兵划分 <code>partition()</code> ，就可将最差的递归深度控制在 $O(logN)$ （每轮递归的子数组长度都 $≤$ 当前数组长度 $/2$ ），即实现最差空间复杂度 $O(logN)$ 。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> quickSort(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> l, <span class="built_in">int</span> r) &#123;</span><br><span class="line">    <span class="comment">// 子数组长度为 1 时终止递归</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="comment">// 哨兵划分操作</span></span><br><span class="line">        <span class="built_in">int</span> i = partition(nums, l, r);</span><br><span class="line">        <span class="comment">// 仅递归至较短子数组，控制递归深度</span></span><br><span class="line">        <span class="keyword">if</span> (i - l &lt; r - i) &#123;</span><br><span class="line">            quickSort(nums, l, i - <span class="number">1</span>);</span><br><span class="line">            l = i + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            quickSort(nums, i + <span class="number">1</span>, r);</span><br><span class="line">            r = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> partition(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> l, <span class="built_in">int</span> r) &#123;</span><br><span class="line">    <span class="comment">// 以 nums[l] 作为基准数</span></span><br><span class="line">    <span class="built_in">int</span> i = l, j = r;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= nums[l]) j--;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= nums[l]) i++;</span><br><span class="line">        swap(nums, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, i, l);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> swap(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> i, <span class="built_in">int</span> j) &#123;</span><br><span class="line">    <span class="comment">// 交换 nums[i] 和 nums[j]</span></span><br><span class="line">    <span class="built_in">int</span> tmp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="滚动窗口"><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/illustration-of-algorithm/7fdcue/">滚动窗口</a></h1>
<blockquote>
<p>输入：target = 12<br>
输出：[[3, 4, 5]]<br>
解释：在上述示例中，存在一个连续正整数序列的和为 12，为 [3, 4, 5]。</p>
</blockquote>
<p>本题可以使用求和公式求解，但是我想要记录一下另外一种方法，<em><strong>滑动窗口</strong></em>。</p>
<p>思路如下：传入<code>target</code>，找到一个数组求和等于它。我们可以假设一个一个小窗口<br>
窗口初始位置<code>i=1</code>,末尾位置为<code>j=2</code>,窗口求和<code>sum=3</code>。<br>
当<code>i&lt;j</code>时不断循环，一开始<code>sum=3 &lt; target</code>。那我们就让<code>j++</code>,相当于窗口扩大，<code>sum += j </code>为<code>6</code> 此时<code>sum &lt; target</code>,重复刚刚的过程。<code>sum=10 &lt; target</code>,当<code>sum=15 &gt;target </code> 让窗口缩小，左侧移动，<code>i++</code>,此时窗口<code>sum</code>减小，<code>sum -= i</code> 为<code>14</code>，重复上述逻辑，<code>i++ sum-=i</code> 为<code>12</code>，那我们就找到了可以组成<code>target</code>数组的首相和尾项。最后组合数组就完成了。</p>
<p>Java代码如下：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>[][] fileCombination(<span class="built_in">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">int</span> i=<span class="number">1</span>,j=<span class="number">2</span>,<span class="keyword">sum</span>=<span class="number">3</span>;</span><br><span class="line">        List&lt;<span class="built_in">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">sum</span>==target)&#123;</span><br><span class="line">                <span class="built_in">int</span>[] ans = <span class="keyword">new</span> <span class="built_in">int</span>[j-i+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">int</span> k=i;k&lt;=j;k++)</span><br><span class="line">                    ans[k-i] = k;</span><br><span class="line">                res.add(ans);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">sum</span>&gt;=target)&#123;</span><br><span class="line">                <span class="keyword">sum</span> -= i;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">sum</span>+=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">0</span>][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="kmp算法">kmp算法</h1>
<p>我们先来看一道题：</p>
<blockquote>
<p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。</p>
</blockquote>
<blockquote>
<p>输入：haystack = “sadbutsad”, needle = “sad”<br>
输出：0<br>
解释：“sad” 在下标 0 和 6 处匹配。<br>
第一个匹配项的下标是 0 ，所以返回 0 。</p>
</blockquote>
<p>暴力代码java:</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">strStr</span><span class="params">(<span class="type">String</span> haystack, <span class="type">String</span> needle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (needle.<span class="built_in">length</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; haystack.<span class="built_in">length</span>() &amp;&amp; j &lt; needle.<span class="built_in">length</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (haystack.<span class="built_in">charAt</span>(i) == needle.<span class="built_in">charAt</span>(j)) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果不匹配，就回退，从第一次匹配的下一个开始，</span></span><br><span class="line">            i = i - j + <span class="number">1</span>;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == needle.<span class="built_in">length</span>())</span><br><span class="line">            <span class="keyword">return</span> i - j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很容易想到的就是暴力算法，通过一个个匹配，如果发现不匹配的地方回退，重新匹配。但是这样的匹配算法的复杂度在$O(n*m)$，算法的效率是低的，那有没有一种高效的算法呢。kmp便是一种高效的字符匹配算法。</p>
<p>首先要理解kmp算法就必须要明白什么是前缀，什么是后缀。<br>
<em>前缀：</em> 不包含最后一个字符的子串。<br>
<em>后缀：</em> 不包含第一个字符的子串。</p>
<blockquote>
<p>$abbab$<br>
<em>前缀：</em>  $a,ab,abb,abba$<br>
<em>后缀：</em>  $b,ab,bab,bbab$</p>
</blockquote>
<p>当我们知道这个概念的时候，我们就可以改进我们的暴力算法了。<br>
试想一下，当我们不断向下匹配的时候，突然发现一个字符匹配不上，按照暴力的思想我们是不是要将待匹配串从头开始和匹配串冲突下一位开始匹配。但是我们其实知道我们待匹配的字符串和匹配串之间是有匹配成功的地方，那我们是不是就可以跳过这个已经成功匹配的地方呢。实际上就是去找前后缀的最大子串。<br>
举一个例子：<br>
匹配串： a b a b a b a b c a<br>
待匹配串：a b a b a b c a</p>
<p>第一次冲突：<br>
a b (a b a b) <mark class="hl-label red">a</mark>  b c a<br>
a b (a b a b) <mark class="hl-label red">c</mark>  a</p>
<p>我们将跳过重复字段(a b a b)那么此时：<br>
a b (a b a b) <mark class="hl-label red">a</mark>  b c a<br>
      (a b a b) <mark class="hl-label red">a</mark>  b c a</p>
<p>kmp算法简单来说就是不让匹配串回退，让它一路向前。跳过最大相同子串，实现剪枝。</p>
<p>实现如下：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> strStr(String haystack, String needle) &#123;</span><br><span class="line">    <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span>[] <span class="keyword">next</span> = <span class="keyword">new</span> <span class="built_in">int</span>[needle.length()];</span><br><span class="line">    getNext(needle, <span class="keyword">next</span>);</span><br><span class="line">    <span class="keyword">while</span> (i &lt; haystack.length()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || haystack.charAt(i) == needle.charAt(j)) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = <span class="keyword">next</span>[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == needle.length())</span><br><span class="line">            <span class="keyword">return</span> i - j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> getNext(String p, <span class="built_in">int</span> <span class="keyword">next</span>[]) &#123;</span><br><span class="line">    <span class="built_in">int</span> length = p.length();</span><br><span class="line">    <span class="built_in">int</span> preIndex = <span class="number">0</span>;<span class="comment">// 前一个位置的下标</span></span><br><span class="line">    <span class="built_in">int</span> <span class="keyword">count</span> = <span class="number">-1</span>;<span class="comment">//公共前缀的长度</span></span><br><span class="line">    <span class="keyword">next</span>[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (preIndex &lt; length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">count</span> == <span class="number">-1</span> || p.charAt(preIndex) == p.charAt(<span class="keyword">count</span>)) &#123;</span><br><span class="line">            preIndex++;</span><br><span class="line">            <span class="keyword">count</span>++;</span><br><span class="line">            <span class="comment">// preIndex执行加1就变成当前位置的下标了</span></span><br><span class="line">            <span class="keyword">next</span>[preIndex] = <span class="keyword">count</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">count</span> = <span class="keyword">next</span>[<span class="keyword">count</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="快速幂算法">快速幂算法</h1>
<p>首先我们将 n 表示为 2 进制，举一个例子：<br>
$3^{13} = 3^{(1101)_2} = 3^8 \cdot 3^4 \cdot 3^1$<br>
因为 n 有 $\lfloor \log_2 n \rfloor + 1$ 个二进制位，因此当我们知道了$a^1$, $a^2$, $a^4$, $a^8$, …,后,我们只用计算 $O(logn)$次乘法就可以计算出 $a^n$。</p>
<div class="tabs" id="初始化代码"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="初始化代码-1">Python</button><button type="button" class="tab " data-href="初始化代码-2">C++</button><button type="button" class="tab " data-href="初始化代码-3">Java</button></ul><div class="tab-contents"><div class="tab-item-content active" id="初始化代码-1"><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">def</span> binpow(a, b):</span><br><span class="line">    res = <span class="number">1</span></span><br><span class="line">    <span class="meta">if</span>(<span class="keyword">b</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = <span class="number">1</span> / x<span class="comment">;</span></span><br><span class="line">            <span class="keyword">b</span> = -b<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">while</span> <span class="keyword">b</span> &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="meta">if</span> (<span class="keyword">b</span> &amp; <span class="number">1</span>):</span><br><span class="line">            res = res * a</span><br><span class="line">        a = a * a</span><br><span class="line">        <span class="keyword">b</span> &gt;&gt;= <span class="number">1</span></span><br><span class="line">    return res</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">binpow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b)</span> &#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(b &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            b = -b;</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = res * a;</span><br><span class="line">    a = a * a;</span><br><span class="line">    b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="初始化代码-3"><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0.0f</span>) <span class="keyword">return</span> <span class="number">0.0</span>d;</span><br><span class="line">        <span class="type">long</span> b = n;</span><br><span class="line">        <span class="type">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(b &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            b = -b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>((b &amp; <span class="number">1</span>) == <span class="number">1</span>) res *= x;</span><br><span class="line">            x *= x;</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h1 id="动态规划">动态规划</h1>
<ol>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/description/?envType=daily-question&amp;envId=2024-03-24">零钱兑换</a></li>
</ol>
<blockquote>
<p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。<br>
计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。<br>
你可以认为每种硬币的数量是无限的。</p>
</blockquote>
<blockquote>
<p>输入：coins = [1, 2, 5], amount = 11<br>
输出：3  解释：11 = 5 + 5 + 1</p>
</blockquote>
<p>思路：我们将这个问题转化为多个小问题的求解。让这个大问题变成每一个最优小问题的解不就可以了吗。记<code>dp[i] </code>表示<code>i</code>元需要最少的硬币数。<br>
那么状态转移方程就是：<code>dp[i] = min(dp[i],dp[i-coins[j]]+1)</code><br>
解释一下这个<code>dp[i-coins[j]]+1</code>，这个表示i元需要用最少<code>i-coins[j]</code>个硬币和一个<code>coins[j]</code>元的硬币表示。</p>
<p>那么java代码如下：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> max = amount + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="type">int</span>[max];<span class="comment">//表示凑出0元需要硬币的最小个数</span></span><br><span class="line">        Arrays.<span class="built_in">fill</span>(dp,max);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//表示凑出0元需要硬币的个数为0</span></span><br><span class="line">        <span class="comment">//动态思想就是将这个问题分割为多个小问题，我们要求amount就可以先求小的。用小的来求大的。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=amount;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;coins.length;j++)&#123;</span><br><span class="line">                <span class="comment">//当前硬币面值小于我要凑的面值，才可以更新方程</span></span><br><span class="line">                <span class="keyword">if</span>(coins[j]&lt;=i)dp[i] = Math.<span class="built_in">min</span>(dp[i],dp[i-coins[j]]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount]&gt;amount?<span class="number">-1</span>:dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>dp问题最重要的就是将问题由大化小，通过去寻求每一个小问题的最优解从而求得大问题的最优解。去寻找问题的状态转移方程。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://2021Dt.github.io">dp2024</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://2021dt.github.io/posts/9505ccb9/">http://2021dt.github.io/posts/9505ccb9/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://2021Dt.github.io" target="_blank">dpのweb</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post_share"><div class="social-share" data-image="/img/cover2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><link rel="stylesheet" href="/" media="defer" onload="this.media='all'"/><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">赞助</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></button></div><audio id="coinAudio" src="https://npm.elemecdn.com/akilar-candyassets@1.0.36/audio/aowu.m4a"></audio><script defer="defer" src="/"></script><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/6e827460/" title="机器学习"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">机器学习</div></div></a></div><div class="next-post pull-right"><a href="/posts/24b9c3a5/" title="b站专栏视频爬取"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">b站专栏视频爬取</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"></div><div class="author_top is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">dp2024</div><div class="author-info__description">时光流转愿你与珍爱之人再次相遇</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/2021Dt"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">dp在此欢迎您光临小破站 (՞•Ꙫ•՞)</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">1.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%93%BE%E8%A1%A8"><span class="toc-number">1.1.</span> <span class="toc-text">初始化链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E7%BB%93%E7%82%B9"><span class="toc-number">1.2.</span> <span class="toc-text">插入结点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9"><span class="toc-number">1.3.</span> <span class="toc-text">删除结点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E7%BB%93%E7%82%B9%E5%92%8C%E6%9F%A5%E6%89%BE%E7%BB%93%E7%82%B9"><span class="toc-number">1.4.</span> <span class="toc-text">访问结点和查找结点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.</span> <span class="toc-text">数组和链表的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%93%BE%E8%A1%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.</span> <span class="toc-text">常见链表类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8"><span class="toc-number">1.7.</span> <span class="toc-text">链表的基本应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.8.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0"><span class="toc-number">1.9.</span> <span class="toc-text">链表算法练习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A81"><span class="toc-number">1.9.1.</span> <span class="toc-text">反转链表1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E5%88%97%E8%A1%A82"><span class="toc-number">1.9.2.</span> <span class="toc-text">反转列表2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9"><span class="toc-number">1.9.3.</span> <span class="toc-text">删除节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%92%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="toc-number">1.9.4.</span> <span class="toc-text">倒序查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">1.9.5.</span> <span class="toc-text">合并有序链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E7%9B%B8%E5%90%8C%E7%BB%93%E7%82%B9"><span class="toc-number">1.9.6.</span> <span class="toc-text">查找相同结点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97"><span class="toc-number">2.</span> <span class="toc-text">栈与队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">2.1.</span> <span class="toc-text">栈的常用操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.</span> <span class="toc-text">队列的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97"><span class="toc-number">2.2.1.</span> <span class="toc-text">双向队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E9%94%BB%E7%82%BC"><span class="toc-number">2.3.</span> <span class="toc-text">算法锻炼</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E6%A0%88"><span class="toc-number">2.3.1.</span> <span class="toc-text">最小栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-number">2.3.2.</span> <span class="toc-text">数据流中的中位数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%9C%B0%E5%9D%80"><span class="toc-number">3.1.</span> <span class="toc-text">链式地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E6%94%BE%E5%AF%BB%E5%9D%80"><span class="toc-number">3.2.</span> <span class="toc-text">开放寻址</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B"><span class="toc-number">3.2.1.</span> <span class="toc-text">线性探测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E6%96%B9%E6%8E%A2%E6%B5%8B"><span class="toc-number">3.2.2.</span> <span class="toc-text">平方探测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%AC%A1%E5%93%88%E5%B8%8C"><span class="toc-number">3.2.3.</span> <span class="toc-text">多次哈希</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">4.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.</span> <span class="toc-text">常见二叉树类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">4.2.</span> <span class="toc-text">二叉树的遍历</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-number">5.</span> <span class="toc-text">广度优先遍历</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-number">6.</span> <span class="toc-text">深度优先遍历</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">7.</span> <span class="toc-text">排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">7.1.</span> <span class="toc-text">桶排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">7.2.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">7.3.</span> <span class="toc-text">快速排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96"><span class="toc-number">7.4.</span> <span class="toc-text">算法优化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BB%9A%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">8.</span> <span class="toc-text">滚动窗口</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#kmp%E7%AE%97%E6%B3%95"><span class="toc-number">9.</span> <span class="toc-text">kmp算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82%E7%AE%97%E6%B3%95"><span class="toc-number">10.</span> <span class="toc-text">快速幂算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">11.</span> <span class="toc-text">动态规划</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/6e827460/" title="机器学习"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="机器学习"/></a><div class="content"><a class="title" href="/posts/6e827460/" title="机器学习">机器学习</a><time datetime="2024-03-09T04:32:01.000Z" title="发表于 2024-03-09 12:32:01">2024-03-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/9505ccb9/" title="algorithm"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="algorithm"/></a><div class="content"><a class="title" href="/posts/9505ccb9/" title="algorithm">algorithm</a><time datetime="2024-02-28T01:09:47.000Z" title="发表于 2024-02-28 09:09:47">2024-02-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/24b9c3a5/" title="b站专栏视频爬取"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="b站专栏视频爬取"/></a><div class="content"><a class="title" href="/posts/24b9c3a5/" title="b站专栏视频爬取">b站专栏视频爬取</a><time datetime="2024-02-23T06:17:37.000Z" title="发表于 2024-02-23 14:17:37">2024-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/e2aead40/" title="C#核心技术"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./img/6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C#核心技术"/></a><div class="content"><a class="title" href="/posts/e2aead40/" title="C#核心技术">C#核心技术</a><time datetime="2024-02-01T04:59:19.000Z" title="发表于 2024-02-01 12:59:19">2024-02-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4ff615c/" title="C#基础语法"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdnimg.gamekee.com/wiki2.0/images/w_1920/h_1080/829/43637/2022/6/8/919701.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C#基础语法"/></a><div class="content"><a class="title" href="/posts/4ff615c/" title="C#基础语法">C#基础语法</a><time datetime="2024-01-19T07:42:06.000Z" title="发表于 2024-01-19 15:42:06">2024-01-19</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/4.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By dp2024</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust">      </i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="share" type="button" title="右键模式" onclick="changeMouseMode()"><i class="fas fa-mouse"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="iconfont icon-baidu"></i><span>百度搜索</span></a><a class="rightMenu-item" href="#post-comment" onclick="rmf.yinyong()"><i class="fa-solid fa-message"></i><span>引用文本评论</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.click()"><i class="fa fa-arrows-alt"></i><span>全屏显示</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:rmf.switchDarkMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();"><i class="fa fa-book"></i><span>阅读模式</span></a><a class="rightMenu-item" href="javascript:fullScreen();"><i class="fas fa-expand"></i><span>进入全屏</span></a></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo-nine-phi.vercel.app/',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(init,0)
    else getScript('https://cdn.jsdelivr.net/npm/twikoo@1.6.29/dist/twikoo.all.min.js').then(init)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo-nine-phi.vercel.app/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
      
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script src="/js/fangdou.js"></script><script type="text/javascript" src="https://cdn1.tianli0.top/npm/jquery@latest/dist/jquery.min.js"></script><script type="text/javascript" src="/js/rightmenu.js"></script><script type="text/javascript" src="/js/title.js"></script><script src="/js/footer.js"></script><script src="/js/randomPost.js"></script><div class="aplayer no-destroy" data-id="8492083327" data-server="netease" data-type="playlist"   data-order="list" data-fixed="true" data-preload="auto" data-autoplay="false" data-mutex="true" ></div><script type="text/javascript" src="/js/click.js"> </script ><script src="https://cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script src="/js/copy.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script defer src="/js/lunar.js"></script><script defer src="/js/day.js"></script><script defer src="/js/cursor.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script src="/js/share.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.12.0"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/9505ccb9/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover2.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-02-28</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/9505ccb9/&quot;);" href="javascript:void(0);" alt="">algorithm</a><div class="blog-slider__text">自学算法的笔记</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/9505ccb9/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/3352/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cci1.dimtown.com/uploads/2024/01/20240109170350841.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-01-11</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/3352/&quot;);" href="javascript:void(0);" alt="">markdown 基础语法</a><div class="blog-slider__text">对markdown学习过程的一些笔记</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/3352/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/undefined/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cci1.dimtown.com/uploads/2024/02/20240203180542122.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-01-14</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/undefined/&quot;);" href="javascript:void(0);" alt="">markdown 高玩</a><div class="blog-slider__text">对markdown学习过程的一些笔记</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/undefined/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/4ff615c/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdnimg.gamekee.com/wiki2.0/images/w_1920/h_1080/829/43637/2022/6/8/919701.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-01-19</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/4ff615c/&quot;);" href="javascript:void(0);" alt="">C#基础语法</a><div class="blog-slider__text">C#的基础语法，学习可能会忘记的地方，有一定的java，c++基础上手特别快</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/4ff615c/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/8ad0bdc0/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/5.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-01-17</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/8ad0bdc0/&quot;);" href="javascript:void(0);" alt="">爬虫模板</a><div class="blog-slider__text">我常用的爬虫模板</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/8ad0bdc0/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script async src="/js/ali_font.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('article-sort-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__slideInRight');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>